From ca38824cee8aee12915f76ab8a939bc9f9417c4c Mon Sep 17 00:00:00 2001
From: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
Date: Thu, 24 Mar 2022 18:01:13 +0300
Subject: [PATCH 26/85] irqchip: renesas INTSWCD driver

INTSWCD component in Renesas S4 SoC provides delivery of control domain
interrupts to application domain's GiC.

This requires control domain access from application domain where Linux
runs.

Interrupts are defined by macros in
include/dt-bindings/interrupt-controller/renesas-intswcd-r8a779f0.h

Client device tree nodes can use these by
	interrupt-parent = <&intswcd>;
	interrupts = <R8A779F0_INTSWCD_INTOSTM0TINT>;

For each interrupt name, a table entry inside r8a779f0_ihi[] in
drivers/irqchip/irq-renesas-intswcd.c is needed to define the mapping
of this interrupt. As of this commit, only several example interrupts
are defined there.

Signed-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
---
 drivers/irqchip/Kconfig                       |  11 +
 drivers/irqchip/Makefile                      |   1 +
 drivers/irqchip/irq-renesas-intswcd.c         | 430 ++++++++++++++++++
 .../renesas-intswcd-r8a779f0.h                |  15 +
 4 files changed, 457 insertions(+)
 create mode 100644 drivers/irqchip/irq-renesas-intswcd.c
 create mode 100644 include/dt-bindings/interrupt-controller/renesas-intswcd-r8a779f0.h

diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index 6156a065681b..0f9c63fd51d1 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -230,6 +230,14 @@ config RENESAS_INTC_IRQPIN
 	  Enable support for the Renesas Interrupt Controller for external
 	  interrupt pins, as found on SH/R-Mobile and R-Car Gen1 SoCs.
 
+config RENESAS_INTSWCD
+	bool "Renesas SoC Control Domain Interrupts support"
+	depends on ARCH_R8A779F0 || COMPILE_TEST
+	select IRQ_DOMAIN
+	help
+	  Enable support for the Renesas INTSWCD controller that forwards
+	  interrupts from SoC control domain to SoC application domain.
+
 config RENESAS_IRQC
 	bool "Renesas R-Mobile APE6, R-Car Gen{2,3} and RZ/G{1,2} IRQC support" if COMPILE_TEST
 	select GENERIC_IRQ_CHIP
@@ -238,6 +246,9 @@ config RENESAS_IRQC
 	  Enable support for the Renesas Interrupt Controller for external
 	  devices, as found on R-Mobile APE6, R-Car Gen{2,3} and RZ/G{1,2} SoCs.
 
+	  This can be used under Linux if software running in SoC control domain
+	  delegates hardware access to application domain.
+
 config RENESAS_RZA1_IRQC
 	bool "Renesas RZ/A1 IRQC support" if COMPILE_TEST
 	select IRQ_DOMAIN_HIERARCHY
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 94c2885882ee..6d08d00ba0fd 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -49,6 +49,7 @@ obj-$(CONFIG_SIRF_IRQ)			+= irq-sirfsoc.o
 obj-$(CONFIG_JCORE_AIC)			+= irq-jcore-aic.o
 obj-$(CONFIG_RDA_INTC)			+= irq-rda-intc.o
 obj-$(CONFIG_RENESAS_INTC_IRQPIN)	+= irq-renesas-intc-irqpin.o
+obj-$(CONFIG_RENESAS_INTSWCD)		+= irq-renesas-intswcd.o
 obj-$(CONFIG_RENESAS_IRQC)		+= irq-renesas-irqc.o
 obj-$(CONFIG_RENESAS_RZA1_IRQC)		+= irq-renesas-rza1.o
 obj-$(CONFIG_VERSATILE_FPGA_IRQ)	+= irq-versatile-fpga.o
diff --git a/drivers/irqchip/irq-renesas-intswcd.c b/drivers/irqchip/irq-renesas-intswcd.c
new file mode 100644
index 000000000000..a37812ee30ab
--- /dev/null
+++ b/drivers/irqchip/irq-renesas-intswcd.c
@@ -0,0 +1,430 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/interrupt-controller/renesas-intswcd-r8a779f0.h>
+
+enum {
+	INTSWCD_LEVEL = 1,
+	INTSWCD_EDGE
+};
+
+struct intswcd_hwirq_info {
+	unsigned int type;
+	unsigned int parent_irq_offset;
+	unsigned int reg;
+	u32 mask;
+};
+
+struct intswcd_info {
+	const struct intswcd_hwirq_info *ihi;
+	unsigned int ihi_nr;
+	unsigned int level_parent_irqs_nr;
+	unsigned int edge_parent_irqs_nr;
+	unsigned int level_sts_regs_base;
+	unsigned int level_msk_regs_base;
+	unsigned int level_regs_nr;
+	unsigned int edge_sts_regs_base;
+	unsigned int edge_msk_regs_base;
+	unsigned int edge_clr_regs_base;
+	unsigned int edge_regs_nr;
+};
+
+struct intswcd_handler_data;
+
+struct intswcd {
+	void __iomem *regs;
+	const struct intswcd_info *ii;
+	struct irq_domain *domain;
+	raw_spinlock_t lock;
+	struct intswcd_handler_data *hd[];
+};
+
+struct intswcd_handler_data {
+	struct intswcd *swcd;
+	int irq;
+	unsigned int hwirq_nr;
+	unsigned int hwirq[];
+};
+
+#define DEFINE_REG_FUNC(type)						\
+static inline u32 __iomem *type##_reg(struct intswcd *swcd, int reg)	\
+{									\
+	return (u32 __iomem *)(swcd->regs + swcd->ii->type##_regs_base) + reg; \
+}
+
+DEFINE_REG_FUNC(level_sts)
+DEFINE_REG_FUNC(level_msk)
+DEFINE_REG_FUNC(edge_sts)
+DEFINE_REG_FUNC(edge_msk)
+DEFINE_REG_FUNC(edge_clr)
+
+static void intswcd_irq_set_masked(struct irq_data *d, bool masked)
+{
+	struct intswcd *swcd = d->domain->host_data;
+	const struct intswcd_hwirq_info *ihi = &swcd->ii->ihi[d->hwirq];
+	u32 __iomem *reg;
+	u32 val;
+	unsigned long flags;
+
+	if (ihi->type == INTSWCD_EDGE)
+		reg = edge_msk_reg(swcd, ihi->reg);
+	else
+		reg = level_msk_reg(swcd, ihi->reg);
+
+	raw_spin_lock_irqsave(&swcd->lock, flags);
+	val = ioread32(reg);
+	if (masked)
+		val &= ~ihi->mask;	/* mask irq = clear bit */
+	else
+		val |= ihi->mask;	/* unmask irq = set bit */
+	iowrite32(val, reg);
+	raw_spin_unlock_irqrestore(&swcd->lock, flags);
+}
+
+static void intswcd_irq_mask(struct irq_data *d)
+{
+	intswcd_irq_set_masked(d, true);
+}
+
+static void intswcd_irq_unmask(struct irq_data *d)
+{
+	intswcd_irq_set_masked(d, false);
+}
+
+static void intswcd_irq_ack(struct irq_data *d)
+{
+	struct intswcd *swcd = d->domain->host_data;
+	const struct intswcd_hwirq_info *ihi = &swcd->ii->ihi[d->hwirq];
+
+	/* This is called both for level and for edge irqs */
+	if (ihi->type == INTSWCD_EDGE)
+		iowrite32(ihi->mask, edge_clr_reg(swcd, ihi->reg));
+}
+
+static struct irq_chip intswcd_irq_chip = {
+	.name = "intswcd",
+	.irq_mask = intswcd_irq_mask,
+	.irq_unmask = intswcd_irq_unmask,
+	.irq_ack = intswcd_irq_ack,
+};
+
+static int intswcd_irq_map(struct irq_domain *domain, unsigned int irq,
+		irq_hw_number_t hwirq)
+{
+	struct intswcd *swcd = domain->host_data;
+	const struct intswcd_hwirq_info *ihi;
+	irq_flow_handler_t handler;
+
+	if (WARN_ON(hwirq >= swcd->ii->ihi_nr))
+		return -EINVAL;
+	ihi = &swcd->ii->ihi[hwirq];
+
+	if (ihi->type == INTSWCD_LEVEL) {
+		irq_set_status_flags(irq, IRQ_LEVEL);
+		handler = handle_level_irq;
+	} else {
+		irq_clear_status_flags(irq, IRQ_LEVEL);
+		handler = handle_edge_irq;
+	}
+
+	irq_set_chip_and_handler(irq, &intswcd_irq_chip, handler);
+
+	return 0;
+}
+
+static int intswcd_irq_xlate(struct irq_domain *domain, struct device_node *dn,
+		const u32 *intspec, unsigned int intspec_size,
+		unsigned long *out_hwirq, unsigned int *out_type)
+{
+	struct intswcd *swcd = domain->host_data;
+	unsigned int hwirq;
+	const struct intswcd_hwirq_info *ihi;
+
+	if (intspec_size != 1)
+		return -EINVAL;
+	hwirq = intspec[0];
+
+	if (hwirq >= swcd->ii->ihi_nr)
+		return -EINVAL;
+	ihi = &swcd->ii->ihi[hwirq];
+	if (!ihi->type)
+		return -EINVAL;
+
+	*out_hwirq = hwirq;
+	*out_type = ihi->type == INTSWCD_EDGE ?
+		    IRQ_TYPE_EDGE_RISING : IRQ_TYPE_LEVEL_HIGH;
+
+	return 0;
+}
+
+static const struct irq_domain_ops intswcd_domain_ops = {
+	.map = intswcd_irq_map,
+	.xlate = intswcd_irq_xlate,
+};
+
+static void intswcd_irq_handler(struct irq_desc *desc)
+{
+	struct intswcd_handler_data *hd = irq_desc_get_handler_data(desc);
+	struct intswcd *swcd = hd->swcd;
+	const struct intswcd_hwirq_info *ihi;
+	unsigned int i, hwirq;
+	int virq;
+	u32 val;
+
+	chained_irq_enter(irq_desc_get_chip(desc), desc);
+
+	for (i = 0; i < hd->hwirq_nr; i++) {
+		hwirq = hd->hwirq[i];
+		virq = irq_find_mapping(swcd->domain, hwirq);
+		if (!virq)
+			continue;
+
+		ihi = &swcd->ii->ihi[hwirq];
+		if (ihi->type == INTSWCD_EDGE)
+			val = ioread32(edge_sts_reg(swcd, ihi->reg)) &
+			      ioread32(edge_msk_reg(swcd, ihi->reg));
+		else
+			val = ioread32(level_sts_reg(swcd, ihi->reg)) &
+			      ioread32(level_msk_reg(swcd, ihi->reg));
+		if (val & ihi->mask)
+			generic_handle_irq(virq);
+	}
+
+	chained_irq_exit(irq_desc_get_chip(desc), desc);
+}
+
+static inline bool ihi_same_parent(const struct intswcd_hwirq_info *ihi1,
+		const struct intswcd_hwirq_info *ihi2)
+{
+	return ihi1->type == ihi2->type &&
+	       ihi1->parent_irq_offset == ihi2->parent_irq_offset;
+}
+
+static int intswcd_parse_interrupt_base(struct device *dev,
+		const char *prop, struct of_phandle_args *args)
+{
+	int ret;
+
+	ret = of_parse_phandle_with_args(dev->of_node, prop,
+			"#interrupt-cells", 0, args);
+	if (ret < 0) {
+		dev_err(dev, "failed to parse %s\n", prop);
+		return ret;
+	}
+	if (!irq_find_host(args->np))
+		return -EPROBE_DEFER;
+
+	/* support only GIC dt layout for now */
+	if (args->args_count != 3 || args->args[0] != GIC_SPI) {
+		dev_err(dev, "%s: unsupported dt layout\n", prop);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void intswcd_init_hw(struct intswcd *swcd)
+{
+	const struct intswcd_info *ii = swcd->ii;
+	const struct intswcd_hwirq_info *ihi;
+	unsigned int i;
+
+	/* explicitly mask all interrupts */
+	for (i = 0; i < ii->level_regs_nr; i++)
+		iowrite32(0, level_msk_reg(swcd, i));
+	for (i = 0; i < ii->edge_regs_nr; i++)
+		iowrite32(0, edge_msk_reg(swcd, i));
+
+	/* explicitly clear all edge interrupts */
+	for (i = 0; i < ii->ihi_nr; i++) {
+		ihi = &ii->ihi[i];
+		if (ihi->type == INTSWCD_EDGE)
+			iowrite32(ihi->mask, edge_clr_reg(swcd, ihi->reg));
+	}
+
+}
+
+static int intswcd_probe(struct platform_device *pdev)
+{
+	struct intswcd *swcd;
+	const struct intswcd_info *ii;
+	const struct intswcd_hwirq_info *ihi, *ihi2;
+	struct of_phandle_args level_args, edge_args, args;
+	struct intswcd_handler_data *hd;
+	unsigned int i, j, k, hd_i, hd_count, hwirq_nr;
+	int ret;
+
+	ii = of_device_get_match_data(&pdev->dev);
+
+	hd_count = ii->level_parent_irqs_nr + ii->edge_parent_irqs_nr;
+	swcd = devm_kzalloc(&pdev->dev, struct_size(swcd, hd, hd_count),
+			GFP_KERNEL);
+	if (!swcd)
+		return -ENOMEM;
+	swcd->ii = ii;
+
+	raw_spin_lock_init(&swcd->lock);
+
+	for (i = 0; i < ii->ihi_nr; i++) {
+		ihi = &ii->ihi[i];
+
+		switch (ihi->type) {
+		case INTSWCD_LEVEL:
+			hd_i = ihi->parent_irq_offset;
+			break;
+		case INTSWCD_EDGE:
+			hd_i = ihi->parent_irq_offset +
+					ii->level_parent_irqs_nr;
+			break;
+		default:
+			continue;
+		}
+
+		/* skip already processed parent */
+		if (swcd->hd[hd_i])
+			continue;
+
+		/* count number of child interrupts sharing this parent */
+		hwirq_nr = 1;
+		for (j = i + 1; j < ii->ihi_nr; j++) {
+			ihi2 = &ii->ihi[j];
+			if (ihi_same_parent(ihi, ihi2))
+				hwirq_nr++;
+		}
+
+		/* create and populate handler data object */
+		hd = devm_kzalloc(&pdev->dev, struct_size(hd, hwirq, hwirq_nr),
+				GFP_KERNEL);
+		if (!hd)
+			return -ENOMEM;
+
+		hd->swcd = swcd;
+		swcd->hd[hd_i] = hd;
+
+		hd->irq = -1;		/* for now */
+		hd->hwirq_nr = hwirq_nr;
+		for (j = i, k = 0; j < ii->ihi_nr; j++) {
+			ihi2 = &ii->ihi[j];
+			if (ihi_same_parent(ihi, ihi2))
+				hd->hwirq[k++] = j;
+		}
+	}
+
+	swcd->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(swcd->regs)) {
+		dev_err(&pdev->dev, "failed to map registers\n");
+		return PTR_ERR(swcd->regs);
+	}
+
+	ret = intswcd_parse_interrupt_base(&pdev->dev, "first-level-interrupt",
+			&level_args);
+	if (ret)
+		return ret;
+	ret = intswcd_parse_interrupt_base(&pdev->dev, "first-edge-interrupt",
+			&edge_args);
+	if (ret)
+		return ret;
+
+	intswcd_init_hw(swcd);
+
+	swcd->domain = irq_domain_add_linear(pdev->dev.of_node, ii->ihi_nr,
+			&intswcd_domain_ops, swcd);
+	if (!swcd->domain)
+		return -ENOMEM;
+
+	for (i = 0; i < hd_count; i++) {
+		hd = swcd->hd[i];
+		if (!hd)
+			continue;
+		ihi = &swcd->ii->ihi[hd->hwirq[0]];
+
+		args = ihi->type == INTSWCD_EDGE ? edge_args : level_args;
+		/* NOTE: here is a dependency in GIC dt layout */
+		args.args[1] += ihi->parent_irq_offset;
+
+		ret = irq_create_of_mapping(&args);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "could not map parent for %s/%d\n",
+				ihi->type == INTSWCD_EDGE ? "edge" : "level",
+				ihi->parent_irq_offset);
+			goto map_err;
+		}
+
+		hd->irq = ret;
+		irq_set_chained_handler_and_data(hd->irq,
+				intswcd_irq_handler, hd);
+	}
+
+	platform_set_drvdata(pdev, swcd);
+	return 0;
+
+map_err:
+	for (i = 0; i < hd_count; i++) {
+		hd = swcd->hd[i];
+		if (hd && hd->irq >= 0)
+			irq_set_chained_handler_and_data(hd->irq, NULL, NULL);
+	}
+
+	irq_domain_remove(swcd->domain);
+	return ret;
+}
+
+static const struct intswcd_hwirq_info r8a779f0_ihi[] = {
+#define ENTRY(_name, _type, _irq_offset, _reg, _bit)	\
+	[R8A779F0_INTSWCD_##_name] = {			\
+		.type = INTSWCD_##_type,		\
+		.parent_irq_offset = _irq_offset,	\
+		.reg = _reg,				\
+		.mask = BIT(_bit),			\
+	},
+
+	ENTRY(INTRIIC0EE,  LEVEL, 33,  9, 0)
+	ENTRY(INTRIIC0TEI, LEVEL, 33,  9, 1)
+	ENTRY(INTRIIC0RI,   EDGE, 24, 13, 0)
+	ENTRY(INTRIIC0TI,   EDGE, 24, 13, 1)
+	ENTRY(INTOSTM0TINT, EDGE, 12,  2, 0)
+
+#undef ENTRY
+};
+
+static const struct intswcd_info r8a779f0_ii = {
+	.ihi = r8a779f0_ihi,
+	.ihi_nr = ARRAY_SIZE(r8a779f0_ihi),
+	.level_parent_irqs_nr = 51,
+	.edge_parent_irqs_nr = 29,
+	.level_sts_regs_base = 0x000,
+	.level_msk_regs_base = 0x040,
+	.level_regs_nr = 14,
+	.edge_sts_regs_base = 0x200,
+	.edge_msk_regs_base = 0x250,
+	.edge_clr_regs_base = 0x2a0,
+	.edge_regs_nr = 17,
+};
+
+static const struct of_device_id intswcd_of_table[] = {
+	{
+		.compatible = "renesas,intswcd-r8a779f0",
+		.data = &r8a779f0_ii,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, intswcd_of_table);
+
+static struct platform_driver intswcd_driver = {
+	.driver = {
+		.name = "renesas-intswcd",
+		.of_match_table = intswcd_of_table,
+	},
+	.probe = intswcd_probe,
+};
+builtin_platform_driver(intswcd_driver);
+
+MODULE_AUTHOR("Nikita Yushchenko <nikita.yoush@cogentembedded.com>");
+MODULE_DESCRIPTION("Renesas INTSWCD driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/interrupt-controller/renesas-intswcd-r8a779f0.h b/include/dt-bindings/interrupt-controller/renesas-intswcd-r8a779f0.h
new file mode 100644
index 000000000000..2cd5405e1375
--- /dev/null
+++ b/include/dt-bindings/interrupt-controller/renesas-intswcd-r8a779f0.h
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#ifndef _DT_BINDINGS_INTERRUPT_CONTROLLER_RENESAS_INTSWCD_R8A779F0_H
+#define _DT_BINDINGS_INTERRUPT_CONTROLLER_RENESAS_INTSWCD_R8A779F0_H
+
+/* The below numbers must be all unique */
+
+/* RIIC */
+#define R8A779F0_INTSWCD_INTRIIC0EE	0
+#define R8A779F0_INTSWCD_INTRIIC0TEI	1
+#define R8A779F0_INTSWCD_INTRIIC0RI	2
+#define R8A779F0_INTSWCD_INTRIIC0TI	3
+#define R8A779F0_INTSWCD_INTOSTM0TINT	4
+
+#endif
-- 
2.39.2

