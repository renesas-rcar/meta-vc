From 5014386cd46d7634da273452c2bb713d3aa133d1 Mon Sep 17 00:00:00 2001
From: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
Date: Sat, 28 Oct 2023 12:23:52 +0600
Subject: [PATCH 75/85] net: ethernet: renesas: rswitch2: fix coding style
 violations

Signed-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
---
 .../ethernet/renesas/rswitch2/rswitch2_eth.c  | 290 +++++++-----------
 .../ethernet/renesas/rswitch2/rswitch2_fwd.c  |  67 ++--
 .../ethernet/renesas/rswitch2/rswitch2_main.c |   1 -
 .../renesas/rswitch2/rswitch2_platf.c         |  42 +--
 4 files changed, 143 insertions(+), 257 deletions(-)

diff --git a/drivers/net/ethernet/renesas/rswitch2/rswitch2_eth.c b/drivers/net/ethernet/renesas/rswitch2/rswitch2_eth.c
index 8de689c40c91..297ab4b0a9ea 100644
--- a/drivers/net/ethernet/renesas/rswitch2/rswitch2_eth.c
+++ b/drivers/net/ethernet/renesas/rswitch2/rswitch2_eth.c
@@ -93,20 +93,17 @@ static int rswitch2_gwca_init(struct rswitch2_drv *rsw2)
 		goto err_out;
 	}
 
-
 	ret = rswitch2_gwca_set_state(rsw2, gwmc_reset);
-		if (ret != 0) {
-			rsw2_err(MSG_GEN, "Failed to set GWCA reset state\n");
-			goto err_out;
-		}
-
+	if (ret != 0) {
+		rsw2_err(MSG_GEN, "Failed to set GWCA reset state\n");
+		goto err_out;
+	}
 
 	ret = rswitch2_gwca_set_state(rsw2, gwmc_disable);
-		if (ret != 0) {
-			rsw2_err(MSG_GEN, "Failed to set GWCA disable state\n");
-			goto err_out;
-		}
-
+	if (ret != 0) {
+		rsw2_err(MSG_GEN, "Failed to set GWCA disable state\n");
+		goto err_out;
+	}
 
 	ret = rswitch2_gwca_set_state(rsw2, gwmc_config);
 	if (ret != 0) {
@@ -281,11 +278,10 @@ static void rswitch2_phy_state_change(struct net_device *ndev)
 	phydev = ndev->phydev;
 
 	rsw2_info(MSG_GEN, "Link change(%d): %s uses %s at %d Mbps\n", phydev->link, ndev->name, phy_modes(phydev->interface), phydev->speed);
-	if(phydev->speed == SPEED_10000)
+	if (phydev->speed == SPEED_10000)
 		return;
 
-	if(!phydev->link) {
-
+	if (!phydev->link) {
 		void __iomem *etha_base_addr;
 		phy_interface_t phy_iface;
 		int speed;
@@ -296,7 +292,7 @@ static void rswitch2_phy_state_change(struct net_device *ndev)
 
 		/* ETHA state machine will lock up due to SerDes connection in S4 ES 1.0
 		 * Lockup can be release by switching SerDes to USXGMII */
-		if(phy_port->phy_iface != PHY_INTERFACE_MODE_USXGMII) {
+		if (phy_port->phy_iface != PHY_INTERFACE_MODE_USXGMII) {
 			reg_val = FIELD_PREP(EAMC_OPC, emac_disable);
 			iowrite32(reg_val, etha_base_addr + RSW2_ETHA_EAMC);
 
@@ -324,22 +320,19 @@ static void rswitch2_phy_state_change(struct net_device *ndev)
 
 		rsw2_notice(MSG_GEN, "================= Link Up start (%s) ==================\n", ndev->name);
 
-		if(phy_port->phy_iface != PHY_INTERFACE_MODE_USXGMII) {
+		if (phy_port->phy_iface != PHY_INTERFACE_MODE_USXGMII) {
 			phy_port_num = eth_port->port_num - eth_port->rsw2->num_of_cpu_ports;
 
+			ret = rswitch2_emac_set_state(ndev, emac_config);
+			if (ret < 0)
+				rsw2_err(MSG_GEN, "Port set state 'config' failed\n");
+			else
+				rsw2_dbg(MSG_GEN, "Port set state 'config' SUCCEEDED\n");
 
-		ret = rswitch2_emac_set_state(ndev, emac_config);
-		if (ret < 0) {
-			rsw2_err(MSG_GEN, "Port set state 'config' failed\n");
-		}
-		else {
-			rsw2_dbg(MSG_GEN, "Port set state 'config' SUCCEEDED\n");
-		}
-
-		reg_val = ioread32(phy_port->rmac_base_addr + RSW2_RMAC_MPIC);
-		reg_val = reg_val & ~0x1Fu;
+			reg_val = ioread32(phy_port->rmac_base_addr + RSW2_RMAC_MPIC);
+			reg_val = reg_val & ~0x1Fu;
 
-		switch (phydev->speed) {
+			switch (phydev->speed) {
 			case SPEED_100:
 				reg_val |= FIELD_PREP(MPIC_LSC, rsw2_rmac_100mbps);
 				reg_val |= FIELD_PREP(MPIC_PIS, rsw2_rmac_gmii);
@@ -368,28 +361,24 @@ static void rswitch2_phy_state_change(struct net_device *ndev)
 				rsw2_err(MSG_GEN, "Unsupported Speed\n");
 				spin_unlock_irqrestore(&rsw2->lock, flags);
 				return;
-		}
+			}
 
-		rsw2_notice(MSG_GEN, "Link change: %s uses %s at %d Mbps\n", ndev->name, phy_modes(phydev->interface), phydev->speed);
+			rsw2_notice(MSG_GEN, "Link change: %s uses %s at %d Mbps\n", ndev->name, phy_modes(phydev->interface), phydev->speed);
 
-		iowrite32(reg_val, phy_port->rmac_base_addr + RSW2_RMAC_MPIC);
-		rsw2_dbg(MSG_GEN, "reg_val=0x%.8x (expected): 0x%.8x\n", ioread32(phy_port->rmac_base_addr + RSW2_RMAC_MPIC), reg_val);
+			iowrite32(reg_val, phy_port->rmac_base_addr + RSW2_RMAC_MPIC);
+			rsw2_dbg(MSG_GEN, "reg_val=0x%.8x (expected): 0x%.8x\n", ioread32(phy_port->rmac_base_addr + RSW2_RMAC_MPIC), reg_val);
 
-		ret = rswitch2_emac_set_state(ndev, emac_disable);
-		if (ret < 0) {
-			rsw2_err(MSG_GEN, "Port set state 'disable' failed\n");
-		}
-		else {
-			rsw2_dbg(MSG_GEN, "Port set state 'disable' SUCCEEDED\n");
-		}
+			ret = rswitch2_emac_set_state(ndev, emac_disable);
+			if (ret < 0)
+				rsw2_err(MSG_GEN, "Port set state 'disable' failed\n");
+			else
+				rsw2_dbg(MSG_GEN, "Port set state 'disable' SUCCEEDED\n");
 
-		ret = rswitch2_emac_set_state(ndev, emac_operation);
-		if (ret < 0) {
-			rsw2_err(MSG_GEN, "Port set state 'operation' failed\n");
-		}
-		else {
-			rsw2_dbg(MSG_GEN, "Port set state 'operation' SUCCEEDED\n");
-		}
+			ret = rswitch2_emac_set_state(ndev, emac_operation);
+			if (ret < 0)
+				rsw2_err(MSG_GEN, "Port set state 'operation' failed\n");
+			else
+				rsw2_dbg(MSG_GEN, "Port set state 'operation' SUCCEEDED\n");
 		}
 
 		rswitch2_serdes_init(ndev, true);
@@ -402,15 +391,14 @@ static void rswitch2_phy_state_change(struct net_device *ndev)
 	if (netif_msg_link(rsw2)) {
 		int phy_speed = 0;
 
-		if(phydev->link)
+		if (phydev->link)
 			phy_speed =phydev->speed;
 
 		phy_print_status(phydev);
 
 		rsw2_info(MSG_GEN, "Link status changed. PHY %d UID 0x%08x Link = %d Speed = %d\n",
 				  phydev->mdio.addr, phydev->phy_id, phydev->link, phy_speed);
-	}
-	else {
+	} else {
 		rsw2_dbg(MSG_GEN,"PHY state change but no msg link!\n");
 	}
 }
@@ -766,7 +754,6 @@ static void rswitch2_serdes_check_operation(struct timer_list *t)
 	unsigned long flags;
 	u32 reg_val;
 
-
 	/* FIXME: May there more elegant way to get eth_port /rsw2 data? */
 	struct rswitch2_drv *rsw2;
 	struct net_device *ndev = phy_port->phy->attached_dev;
@@ -777,15 +764,13 @@ static void rswitch2_serdes_check_operation(struct timer_list *t)
 
 	spin_lock_irqsave(&rsw2->lock, flags);
 
-
 	if (phy_port->serdes_usxgmii_op_cnt < RSW2_SERDES_OP_RETRIES) {
 		//Link status is latched, for current status read twice
 		rswitch2_serdes_read32(phy_port->serdes_chan_addr, SR_XS_PCS_STS1, BANK_300);
 		reg_val = rswitch2_serdes_read32(phy_port->serdes_chan_addr, SR_XS_PCS_STS1, BANK_300);
 		if (reg_val & 0x04) {
 			rsw2_notice(MSG_SERDES, "SerDes USXGMII is operational on port %s %s (retries = %d)\n", phy_port->mii_bus->name, phy_port->mii_bus->id, phy_port->serdes_usxgmii_op_cnt);
-		}
-		else {
+		} else {
 			rsw2_notice(MSG_SERDES, "Resetting SerDes USXGMII on port %s %s (retries = %d)\n", phy_port->mii_bus->name, phy_port->mii_bus->id, phy_port->serdes_usxgmii_op_cnt);
 
 
@@ -798,8 +783,7 @@ static void rswitch2_serdes_check_operation(struct timer_list *t)
 			phy_port->serdes_usxgmii_op_cnt++;
 			mod_timer(&phy_port->serdes_usxgmii_op_timer, jiffies + msecs_to_jiffies(RSW2_SERDES_OP_TIMER_INTERVALL));
 		}
-	}
-	else {
+	} else {
 		rsw2_err(MSG_SERDES, "Could not bring SerDes USXGMII on port %s %s into operational state. Giving up!\n", phy_port->mii_bus->name, phy_port->mii_bus->id);
 	}
 
@@ -832,7 +816,7 @@ static int rswitch2_serdes_init(struct net_device *ndev, bool check_op)
 	//printk("%s: sw0p%d  phy_mode=%d\n", __FUNCTION__, port_num, ndev->phydev->interface );
 	switch (phy_port->phy_iface) {
 	case PHY_INTERFACE_MODE_SGMII:
-		if((phy_port->phy->speed != SPEED_100) && (phy_port->phy->speed != SPEED_1000)) {
+		if ((phy_port->phy->speed != SPEED_100) && (phy_port->phy->speed != SPEED_1000)) {
 			phy_speed = SPEED_100;
 			rsw2_notice(MSG_SERDES, "No valid default speed. Setting to %d Mbit/s\n", phy_speed);
 		} else
@@ -842,7 +826,7 @@ static int rswitch2_serdes_init(struct net_device *ndev, bool check_op)
 		break;
 
 	case PHY_INTERFACE_MODE_USXGMII:
-		if(phy_port->phy->speed != SPEED_2500) {
+		if (phy_port->phy->speed != SPEED_2500) {
 			phy_speed = SPEED_2500;
 			rsw2_notice(MSG_SERDES, "No valid default speed. Setting to %d Mbit/s\n", phy_speed);
 		} else
@@ -943,8 +927,6 @@ static void rswitch2_stat_timer(struct timer_list *t)
 
 	mod_timer(&eth_port->stat_timer, jiffies + msecs_to_jiffies(RSW2_STAT_TIMER_INTERVALL));
 	spin_unlock_irqrestore(&eth_port->rsw2->lock, flags);
-
-
 }
 
 /*static int rswitch2_mac_set_speed(struct rswitch2_eth_port *eth_port)
@@ -1019,7 +1001,7 @@ static int rswitch2_eth_open(struct net_device *ndev)
 	/* Gateway port */
 	if (intern_port != NULL) {
 		int cur_q;
-		const uint 	num_of_rx_q = ARRAY_SIZE(intern_port->rx_q);
+		const uint num_of_rx_q = ARRAY_SIZE(intern_port->rx_q);
 
 		ret = rswitch2_gwca_set_state(rsw2, gwmc_operation);
 		if (ret != 0) {
@@ -1043,8 +1025,7 @@ static int rswitch2_eth_open(struct net_device *ndev)
 	}
 	else {
 		int cur_q;
-		const uint 	num_of_rx_q = ARRAY_SIZE(phy_port->rx_q);
-
+		const uint num_of_rx_q = ARRAY_SIZE(phy_port->rx_q);
 
 		rsw2_notice(MSG_GEN, "physical port open(): '%s'\n", ndev->name);
 		for (cur_q = 0; cur_q < num_of_rx_q; cur_q++) {
@@ -1053,13 +1034,11 @@ static int rswitch2_eth_open(struct net_device *ndev)
 
 		netif_tx_start_all_queues(ndev);
 
-
 		ret = rswitch2_serdes_init(ndev, false);
 		if (ret != 0) {
 			rsw2_err(MSG_SERDES, "%s: rswitch2_serdes_init failed: %d\n", ndev->name, ret);
 			return ret;
-		}
-		else {
+		} else {
 			rsw2_info(MSG_SERDES, "%s: rswitch2_serdes_init SUCCESS\n", ndev->name);
 		}
 
@@ -1068,7 +1047,6 @@ static int rswitch2_eth_open(struct net_device *ndev)
 		if (phy_port != NULL) {
 			rsw2_info(MSG_SERDES, "physical port open(): '%s'\n", ndev->name);
 			phy_start(ndev->phydev);
-
 		}
 
 		phy_attached_info(ndev->phydev);
@@ -1087,7 +1065,7 @@ rswitch2_netdev_get_rx_q(struct net_device *ndev, uint q, struct rsw2_rx_q_data
 	intern_port = eth_port->intern_port;
 	phy_port = eth_port->phy_port;
 
-	if(intern_port)
+	if (intern_port)
 		*rx_q = &intern_port->rx_q[q];
 	else
 		*rx_q = &phy_port->rx_q[q];
@@ -1106,7 +1084,7 @@ rswitch2_netdev_get_tx_q(struct net_device *ndev, uint q, struct rsw2_tx_q_data
 	intern_port = eth_port->intern_port;
 	phy_port = eth_port->phy_port;
 
-	if(intern_port)
+	if (intern_port)
 		*tx_q = &intern_port->tx_q[q];
 	else
 		*tx_q = &phy_port->tx_q[q];
@@ -1130,11 +1108,10 @@ static void rswitch2_disable_rx(struct net_device *ndev)
 	intern_port = eth_port->intern_port;
 	phy_port = eth_port->phy_port;
 
-	if(intern_port) {
+	if (intern_port)
 		num_of_rx_queues = ARRAY_SIZE(intern_port->rx_q);
-	} else {
+	else
 		num_of_rx_queues = ARRAY_SIZE(phy_port->rx_q);
-	}
 
 	for (q = 0; q < num_of_rx_queues; q++) {
 		u32 reg_queue;
@@ -1168,17 +1145,15 @@ static int rswitch2_tx_free(struct net_device *ndev, int q)
 	u32 data_ptr = 0;
 	unsigned int data_len = 0;
 
-
 	eth_port = netdev_priv(ndev);
 	rsw2 = eth_port->rsw2;
 
 	intern_port = eth_port->intern_port;
 	phy_port = eth_port->phy_port;
-	if(intern_port) {
+	if (intern_port)
 		tx_q = &intern_port->tx_q[q];
-	} else {
+	else
 		tx_q = &phy_port->tx_q[q];
-	}
 
 	while (tx_q->cur_desc - tx_q->dirty_desc > 0) {
 		entry = tx_q->dirty_desc % tx_q->entries;
@@ -1190,7 +1165,6 @@ static int rswitch2_tx_free(struct net_device *ndev, int q)
 		/* Descriptor type must be checked before all other reads */
 		dma_rmb();
 
-
 		/* Free the original skb */
 		if (tx_q->skb[entry]) {
 			bool txc = false;
@@ -1287,7 +1261,6 @@ static int rswitch2_eth_close(struct net_device *ndev)
 			rswitch2_tx_free(ndev, cur_q);
 		}
 		phy_stop(ndev->phydev);
-
 	}
 
 	return 0;
@@ -1319,11 +1292,10 @@ static bool rswitch2_rx(struct net_device *ndev, int budget, int q)
 
 	intern_port = eth_port->intern_port;
 	phy_port = eth_port->phy_port;
-	if(intern_port) {
+	if (intern_port)
 		rx_q = &intern_port->rx_q[q];
-	} else {
+	else
 		rx_q = &phy_port->rx_q[q];
-	}
 	rsw2 = eth_port->rsw2;
 
 
@@ -1335,7 +1307,7 @@ static bool rswitch2_rx(struct net_device *ndev, int budget, int q)
 		rx_desc = &rx_q->desc_ring[entry];
 		//printk("Abs. Q: %d: RX desc. entry %d of %ld\n", q + rx_q->offset, entry, rx_q->entries);
 
-		if(FIELD_GET(RSW2_DESC_DT, rx_desc->die_dt) == DT_FEMPTY)
+		if (FIELD_GET(RSW2_DESC_DT, rx_desc->die_dt) == DT_FEMPTY)
 			break;
 
 		/* Descriptor type must be checked before all other reads */
@@ -1362,7 +1334,7 @@ static bool rswitch2_rx(struct net_device *ndev, int budget, int q)
 		napi_gro_receive(&rx_q->napi, skb);
 
 		// TODO
-		if(intern_port) {
+		if (intern_port) {
 			intern_port->rx_pkt_cnt++;
 			intern_port->rx_byte_cnt += pkt_len;
 		}
@@ -1435,11 +1407,10 @@ static int rswitch2_poll(struct napi_struct *napi, int budget)
 
 	intern_port = eth_port->intern_port;
 	phy_port = eth_port->phy_port;
-	if(intern_port) {
+	if (intern_port)
 		q = (rx_q - &intern_port->rx_q[0]);
-	} else {
+	else
 		q = (rx_q - &phy_port->rx_q[0]);
-	}
 
 	reg_queue = (q + rx_q->offset) / 32;
 	bit_queue = (q + rx_q->offset) % 32;
@@ -1448,14 +1419,13 @@ static int rswitch2_poll(struct napi_struct *napi, int budget)
 
 	work_done = rswitch2_rx(ndev, budget, q);
 	rearm_irq = napi_complete_done(napi, work_done);
-	if(rearm_irq) {
+	if (rearm_irq) {
 		/* Re-enable RX interrupts*/
 		spin_lock_irqsave(&rsw2->lock, flags);
 		iowrite32((1 << bit_queue), rsw2->gwca_base_addrs[0] + RSW2_GCWA_GWDIS(reg_queue));
 		iowrite32((1 << bit_queue), rsw2->gwca_base_addrs[0] + RSW2_GCWA_GWDIE(reg_queue));
 		spin_unlock_irqrestore(&rsw2->lock, flags);
-	}
-	else {
+	} else {
 		/* FIXME: Remove this. Just left for debugging purpose */
 		rsw2_notice(MSG_RXTX, "NAPI says: don't rearm\n");
 	}
@@ -1480,7 +1450,6 @@ static netdev_tx_t rswitch2_eth_start_xmit(struct sk_buff *skb, struct net_devic
 	char *data_ptr;
 	unsigned int data_len;
 
-
 	/* Get current q */
 	q = skb_get_queue_mapping(skb);
 
@@ -1542,7 +1511,6 @@ static netdev_tx_t rswitch2_eth_start_xmit(struct sk_buff *skb, struct net_devic
 			skb_tx_timestamp(skb);
 		}
 
-
 		/* HW won't process descriptor until type is set,
 		 * ensure all other items have been written
 		 */
@@ -1603,7 +1571,6 @@ static netdev_tx_t rswitch2_eth_start_xmit(struct sk_buff *skb, struct net_devic
 				tx_desc->info_ds = cpu_to_le16(RSWITCH2_MAX_DESC_SIZE);
 				data_len -= RSWITCH2_MAX_DESC_SIZE;
 				tx_q->skb[entry] = NULL;
-
 			}
 
 			if (eth_port->phy_port) {
@@ -1612,14 +1579,13 @@ static netdev_tx_t rswitch2_eth_start_xmit(struct sk_buff *skb, struct net_devic
 				tx_desc->info1 |= FIELD_PREP(RSW2_DESC_INFO1_FMT, direct_desc);
 				tx_desc->info1 |= FIELD_PREP(RSW2_DESC_INFO1_DV, 1 << port_num);
 			}
-			if(FIELD_GET(RSW2_DESC_DT, dt_type) != DT_FSTART) {
+			if (FIELD_GET(RSW2_DESC_DT, dt_type) != DT_FSTART) {
 				//printk("dt_type: %d\n", dt_type);
-			tx_desc->die_dt = dt_type;
+				tx_desc->die_dt = dt_type;
 			}
 		} while (data_len > 0);
 		dma_wmb();
 		tx_start_desc->die_dt = FIELD_PREP(RSW2_DESC_DT, DT_FSTART);
-
 	}
 
 	/* On multi descriptor transmit, the last entry holds the skb data */
@@ -1636,7 +1602,7 @@ static netdev_tx_t rswitch2_eth_start_xmit(struct sk_buff *skb, struct net_devic
 	spin_unlock_irqrestore(&rsw2->lock, flags);
 
 	/* TODO:: Make generic eth_port counter and use RMAC counters on phy_port */
-	if(eth_port->intern_port) {
+	if (eth_port->intern_port) {
 		eth_port->intern_port->tx_pkt_cnt++;
 		eth_port->intern_port->tx_byte_cnt += skb->len;
 	}
@@ -1646,7 +1612,8 @@ static netdev_tx_t rswitch2_eth_start_xmit(struct sk_buff *skb, struct net_devic
 	return NETDEV_TX_OK;
 }
 
-static void rswitch2_get_ts(struct rswitch2_drv *rsw2) {
+static void rswitch2_get_ts(struct rswitch2_drv *rsw2)
+{
 	struct rswitch2_eth_port *eth_port;
 	struct rswitch2_physical_port *phy_port;
 	struct rswitch2_dma_ts_desc *ts_desc;
@@ -1658,7 +1625,6 @@ static void rswitch2_get_ts(struct rswitch2_drv *rsw2) {
 	uint dest_port_num;
 	uint entry;
 
-
 	ring_entries = rsw2->num_of_tsn_ports * MAX_TS_Q_ENTRIES_PER_PORT;
 	entry = (rsw2->ts_cur_desc) % ring_entries;
 	ts_desc = &rsw2->ts_desc_ring[entry];
@@ -1694,7 +1660,6 @@ static void rswitch2_get_ts(struct rswitch2_drv *rsw2) {
 		entry = (rsw2->ts_cur_desc) % ring_entries;
 		ts_desc = &rsw2->ts_desc_ring[entry];
 	}
-
 }
 
 static irqreturn_t rswitch2_status_interrupt(int irq, void *dev_id)
@@ -1709,7 +1674,7 @@ static irqreturn_t rswitch2_status_interrupt(int irq, void *dev_id)
 	reg_val = ioread32(rsw2->gwca_base_addrs[0] + RSW2_GCWA_GWTSDIS);
 
 	rsw2_dbg(MSG_GEN, "GWTSDIS: 0x%.8x\n", reg_val);
-	if((reg_val & BIT(0)) == BIT(0)) {
+	if ((reg_val & BIT(0)) == BIT(0)) {
 		/* Mask IRQ */
 		iowrite32(BIT(0), rsw2->gwca_base_addrs[0] + RSW2_GCWA_GWTSDID);
 		spin_unlock_irqrestore(&rsw2->lock, flags);
@@ -1749,7 +1714,6 @@ static irqreturn_t rswitch2_eth_interrupt(int irq, void *dev_id)
 	}
 	spin_unlock_irqrestore(&rsw2->lock, flags);
 
-
 	for (reg_num = 0; reg_num < RSWITCH2_CHAIN_REG_NUM; reg_num++) {
 		reg_val = irq_status[reg_num] & irq_active[reg_num];
 
@@ -1770,11 +1734,12 @@ static irqreturn_t rswitch2_eth_interrupt(int irq, void *dev_id)
 
 				if (napi_schedule_prep(cur_napi))
 					__napi_schedule(cur_napi);
-				else
+				else {
 					/* Although this is no real problem, it shouldn't happen.
 					 * It wastes CPU time with unnecessary IRQ handling
 					 */
 					rsw2_warn(MSG_RXTX, "NAPI is already running Q: %d\n", cur_queue);
+				}
 			}
 		}
 	}
@@ -1811,7 +1776,7 @@ static struct net_device_stats *rswitch2_eth_get_stats(struct net_device *ndev)
 	spin_lock_irqsave(&eth_port->rsw2->lock, flags);
 
 	/* Only internal ports can TX */
-	if(intern_port) {
+	if (intern_port) {
 		nstats->rx_packets = intern_port->rx_pkt_cnt;
 		nstats->tx_packets = intern_port->tx_pkt_cnt;
 		nstats->rx_bytes = intern_port->rx_byte_cnt;
@@ -1824,7 +1789,7 @@ static struct net_device_stats *rswitch2_eth_get_stats(struct net_device *ndev)
 		nstats->rx_missed_errors = 0;
 		nstats->rx_over_errors = 0;
 
-	} else if(phy_port) {
+	} else if (phy_port) {
 		rswitch2_phy_port_update_stats(phy_port);
 		nstats->rx_packets = phy_port->rx_pkt_cnt;
 		nstats->tx_packets = phy_port->tx_pkt_cnt;
@@ -1868,14 +1833,13 @@ static int rswitch2_hwstamp_get(struct net_device *ndev, struct ifreq *req)
 	phy_port = eth_port->phy_port;
 
 
-	if(intern_port) {
+	if (intern_port) {
 		rsw2_err(MSG_GEN, "HW get intern port!?\n");
 		return -EINVAL;
 	}
 	rsw2 = eth_port->rsw2;
 	ptp_priv = rsw2->ptp_drv;
 
-
 	config.flags = 0;
 	config.tx_type = ptp_priv->tstamp_tx_ctrl ? HWTSTAMP_TX_ON :
 						    HWTSTAMP_TX_OFF;
@@ -1910,7 +1874,7 @@ static int rswitch2_hwstamp_set(struct net_device *ndev, struct ifreq *req)
 	intern_port = eth_port->intern_port;
 	phy_port = eth_port->phy_port;
 
-	if(intern_port) {
+	if (intern_port) {
 		rsw2_err(MSG_GEN, "HW set intern port!?\n");
 		return -EINVAL;
 	}
@@ -2043,7 +2007,6 @@ static void rswitch2_port_get_mac_addr(struct net_device *port_ndev)
 }
 #endif
 
-
 static void rswitch2_intern_set_mac_addr(struct net_device *ndev)
 {
 	struct rswitch2_drv *rsw2;
@@ -2067,7 +2030,6 @@ static void rswitch2_intern_set_mac_addr(struct net_device *ndev)
 	iowrite32(reg_val, ((volatile void __iomem *)ndev->base_addr) + RSW2_GCWA_GWMAC1);
 }
 
-
 static int rswitch2_eth_mac_addr(struct net_device *ndev, void *p)
 {
 	struct rswitch2_drv *rsw2;
@@ -2076,7 +2038,6 @@ static int rswitch2_eth_mac_addr(struct net_device *ndev, void *p)
 	u8 old_macaddr[ETH_ALEN];
 	u8 *new_macaddr;
 
-
 	eth_port = netdev_priv(ndev);
 	rsw2 = eth_port->rsw2;
 
@@ -2099,8 +2060,7 @@ static int rswitch2_eth_mac_addr(struct net_device *ndev, void *p)
 
 	memcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);
 
-
-	if(eth_port->intern_port) {
+	if (eth_port->intern_port) {
 		rswitch2_intern_set_mac_addr(ndev);
 	} else {
 		/* Update fwd engine */
@@ -2108,13 +2068,12 @@ static int rswitch2_eth_mac_addr(struct net_device *ndev, void *p)
 	}
 	rsw2_fwd_del_l2_entry(rsw2, old_macaddr);
 
-
 	return 0;
 }
 
 static const struct net_device_ops rswitch2_netdev_ops = {
-	.ndo_open				= rswitch2_eth_open,
-	.ndo_stop				= rswitch2_eth_close,
+	.ndo_open			= rswitch2_eth_open,
+	.ndo_stop			= rswitch2_eth_close,
 	.ndo_start_xmit			= rswitch2_eth_start_xmit,
 	.ndo_select_queue		= rswitch2_eth_select_queue,
 	.ndo_get_stats			= rswitch2_eth_get_stats,
@@ -2123,7 +2082,7 @@ static const struct net_device_ops rswitch2_netdev_ops = {
 	.ndo_do_ioctl			= rswitch2_eth_do_ioctl,
 	.ndo_change_mtu			= rswitch2_eth_change_mtu,
 	.ndo_validate_addr		= eth_validate_addr,
-	.ndo_set_mac_address	= rswitch2_eth_mac_addr,
+	.ndo_set_mac_address		= rswitch2_eth_mac_addr,
 };
 
 
@@ -2139,11 +2098,9 @@ static int rswitch2_ts_ring_init(struct rswitch2_drv *rsw2)
 	u32 reg_val;
 	int ret;
 
-
 	rsw2->ts_cur_desc = 0;
 	rsw2->ts_dirty_desc = 0;
 
-
 	/* Create BAT entry for TS descriptors */
 	bat_entry = dma_alloc_coherent(rsw2->dev, sizeof(*bat_entry), &rsw2->bat_ts_dma_addr, GFP_KERNEL);
 	if (!bat_entry) {
@@ -2154,7 +2111,6 @@ static int rswitch2_ts_ring_init(struct rswitch2_drv *rsw2)
 
 	rsw2_info(MSG_RXTX, "BAT TS: BAT entry is at 0x%px DMA: (DMA: 0x%llx)\n", bat_entry, rsw2->bat_ts_dma_addr);
 
-
 	ring_entries = rsw2->num_of_tsn_ports * MAX_TS_Q_ENTRIES_PER_PORT;
 	ts_ring_size = sizeof(*ts_desc) * (ring_entries + 1);
 
@@ -2206,12 +2162,9 @@ static int rswitch2_ts_ring_init(struct rswitch2_drv *rsw2)
 	dma_free_coherent(rsw2->dev, sizeof(*bat_entry), rsw2->bat_ts_addr, rsw2->bat_ts_dma_addr);
 
 bat_alloc_err:
-
 	return ret;
 }
 
-
-
 /* Allocate descriptor base address table */
 static int rswitch2_bat_init(struct rswitch2_drv *rsw2)
 {
@@ -2248,7 +2201,6 @@ static int rswitch2_bat_init(struct rswitch2_drv *rsw2)
 		rsw2->bat_addr[i] = &bat_entry[i];
 	}
 
-
 	for (i = rsw2_be_tx_q_0; i < rsw2_be_tx_q_max_entry; i++) {
 		//pr_info("Creating BAT entry for queue %d (TX queue %d)\n", i, (i - RSW2_BE_TX_Q_OFFSET));
 		bat_entry[i].die_dt = FIELD_PREP(RSW2_DESC_DT, DT_EOS);
@@ -2271,7 +2223,6 @@ static int rswitch2_bat_init(struct rswitch2_drv *rsw2)
 	kfree(rsw2->bat_addr);
 
 bat_ptr_alloc_err:
-
 	return ret;
 }
 
@@ -2382,7 +2333,6 @@ static int rswitch2_rx_ring_init(struct net_device *ndev, uint q, uint q_offset)
 
 	rx_q->desc_ring = dma_alloc_coherent(rsw2->dev, ring_size,
 					     	 	 	 	 &rx_q->desc_dma, GFP_KERNEL);
-
 	if (!rx_q->desc_ring)
 		goto dma_alloc_err;
 
@@ -2439,8 +2389,6 @@ static int rswitch2_tx_ring_init(struct net_device *ndev, uint q, uint q_offset)
 	return -ENOMEM;
 }
 
-
-
 static int rswitch2_tx_ring_format(struct net_device *ndev, int q)
 {
 	struct rswitch2_eth_port *eth_port;
@@ -2484,8 +2432,6 @@ static int rswitch2_tx_ring_format(struct net_device *ndev, int q)
 	return 0;
 }
 
-
-
 static u32 rswitch2_get_msglevel(struct net_device *ndev)
 {
 	struct rswitch2_drv *rsw2;
@@ -2664,7 +2610,6 @@ static int rswitch2_phy_ethtool_set_link_ksettings(struct net_device *ndev,
 	if (!phydev)
 		return -ENODEV;
 
-
 	if (cmd->base.phy_address != phydev->mdio.addr)
 		return -EINVAL;
 
@@ -2707,12 +2652,11 @@ static int rswitch2_phy_ethtool_set_link_ksettings(struct net_device *ndev,
 	return 0;
 }
 
-
 static const struct ethtool_ops rswitch2_ethtool_ops = {
-	.nway_reset			= phy_ethtool_nway_reset,
+	.nway_reset		= phy_ethtool_nway_reset,
 	.get_msglevel		= rswitch2_get_msglevel,
 	.set_msglevel		= rswitch2_set_msglevel,
-	.get_link			= ethtool_op_get_link,
+	.get_link		= ethtool_op_get_link,
 	.get_strings		= rswitch2_get_strings,
 	.get_ethtool_stats	= rswitch2_get_ethtool_stats,
 	.get_sset_count		= rswicth2_get_sset_count,
@@ -2721,8 +2665,6 @@ static const struct ethtool_ops rswitch2_ethtool_ops = {
 	.get_ts_info		= rswitch2_get_ts_info,
 	.get_link_ksettings	= phy_ethtool_get_link_ksettings,
 	.set_link_ksettings	= rswitch2_phy_ethtool_set_link_ksettings,
-	.get_wol			= NULL,
-	.set_wol			= NULL,
 };
 
 
@@ -2751,21 +2693,21 @@ static void rswitch2_init_port_mac(struct net_device *port_ndev)
 	//phy_iface = eth_port->rsw2->port_data[eth_port->port_num-1].phy_iface;
 	phy_iface = phy_port->phy_iface;
 	switch (phy_iface) {
-		case PHY_INTERFACE_MODE_SGMII :
-			//speed may chage during link up. MII is fixed
-			speed = 1000;
-			reg_val |= FIELD_PREP(MPIC_LSC, rsw2_rmac_1000mbps);
-			reg_val |= FIELD_PREP(MPIC_PIS, rsw2_rmac_gmii);
-			break;
-		case PHY_INTERFACE_MODE_USXGMII :
-			//speed may chage during link up. MII is fixed
-			speed = 2500;
-			reg_val |= FIELD_PREP(MPIC_LSC, rsw2_rmac_2500mbps);
-			reg_val |= FIELD_PREP(MPIC_PIS, rsw2_rmac_xgmii);
-			break;
-		default:
-			rsw2_err(MSG_GEN, "Unsupported MAC xMII format %s (%d) on port %d\n",phy_modes(phy_iface), phy_iface, eth_port->port_num-1);
-			//return -EINVAL;
+	case PHY_INTERFACE_MODE_SGMII :
+		//speed may chage during link up. MII is fixed
+		speed = 1000;
+		reg_val |= FIELD_PREP(MPIC_LSC, rsw2_rmac_1000mbps);
+		reg_val |= FIELD_PREP(MPIC_PIS, rsw2_rmac_gmii);
+		break;
+	case PHY_INTERFACE_MODE_USXGMII :
+		//speed may chage during link up. MII is fixed
+		speed = 2500;
+		reg_val |= FIELD_PREP(MPIC_LSC, rsw2_rmac_2500mbps);
+		reg_val |= FIELD_PREP(MPIC_PIS, rsw2_rmac_xgmii);
+		break;
+	default:
+		rsw2_err(MSG_GEN, "Unsupported MAC xMII format %s (%d) on port %d\n",phy_modes(phy_iface), phy_iface, eth_port->port_num-1);
+		//return -EINVAL;
 	}
 
 	iowrite32(reg_val, phy_port->rmac_base_addr + RSW2_RMAC_MPIC);
@@ -2775,7 +2717,6 @@ static void rswitch2_init_port_mac(struct net_device *port_ndev)
 	reg_val |= MPSM_MFF;
 	iowrite32(reg_val, phy_port->rmac_base_addr + RSW2_RMAC_MPSM);
 
-
 	/* Enable broad-/multi-/uni-cast reception of eMAC and pMAC frames*/
 	reg_val = MRAFC_BCENE;
 	reg_val |= MRAFC_MCENE;
@@ -2786,9 +2727,6 @@ static void rswitch2_init_port_mac(struct net_device *port_ndev)
 	iowrite32(reg_val, phy_port->rmac_base_addr + RSW2_RMAC_MRAFC);
 }
 
-
-
-
 static void rswitch2_init_mac_addr(struct net_device *ndev)
 {
 	struct rswitch2_drv *rsw2;
@@ -2801,24 +2739,21 @@ static void rswitch2_init_mac_addr(struct net_device *ndev)
 	eth_port = netdev_priv(ndev);
 	rsw2 = eth_port->rsw2;
 
-
 	port_node = rswitch2_get_port_node(rsw2, (eth_port->port_num - rsw2->num_of_cpu_ports));
 //	dev_node = ndev->dev.of_node;
 	ndev->dev.of_node = port_node;
 
-	if(eth_port->intern_port) {
+	if (eth_port->intern_port) {
 		ret = eth_platform_get_mac_address(rsw2->dev, ndev->dev_addr);
 		if ((ret == 0) && is_valid_ether_addr(ndev->dev_addr)) {
 			/* device tree or NVMEM values are valid so use them */
 			rsw2_info(MSG_GEN, "MAC: '%s' Got valid MAC from eth_platform_get_mac_address()\n", ndev->name);
 
-		}
-		else {
+		} else {
 			rsw2_info(MSG_GEN, "MAC: '%s' INVALID from eth_platform_get_mac_address()\n", ndev->name);
 			eth_hw_addr_random(ndev);
 		}
-	}
-	else {
+	} else {
 		/* Although this calls of_get_mac_addr_nvmem() internally
 		 * it can't succeed because it expects dev.of_node to belong to
 		 * a platform device, which is not possible for the 'port' sub-node
@@ -2844,17 +2779,14 @@ static void rswitch2_init_mac_addr(struct net_device *ndev)
 			ndev->name);
 
 //	ndev->dev.of_node = dev_node;
-
 }
 
-
-
-
 // FIXME: don't re-invent base functions
 static void rswitch_modify(void __iomem *addr, u32 reg, u32 clear, u32 set)
 {
 	iowrite32((ioread32(addr + reg) & ~clear) | set, addr + reg);
 }
+
 // FIXME
 #define MMIS1_CLEAR_FLAGS       0xf
 
@@ -2919,9 +2851,6 @@ static int rswitch2_mdio_access(struct net_device *ndev, bool read,
 
 		/* Clear read completion flag */
 		rswitch_modify(phy_port->rmac_base_addr, RSW2_RMAC_MMIS1, MMIS1_PRACS, MMIS1_PRACS);
-
-
-
 	} else {
 		reg_val = MPSM_PSME | MPSM_MFF;
 		iowrite32((data << 16) | (pop << 13) | (devad << 8) | (phyad << 3) | reg_val,
@@ -3104,13 +3033,12 @@ static int rswitch2_get_phy_config(struct net_device *ndev)
 	phy_port = eth_port->phy_port;
 
 	port_node = rswitch2_get_port_node(rsw2, (eth_port->port_num - rsw2->num_of_cpu_ports));
-	if(port_node) {
+	if (port_node) {
 		ret = of_get_phy_mode(port_node, &phy_port->phy_iface);
 		if (ret != 0) {
 			rsw2_err(MSG_GEN, "of_get_phy_mode failed\n");
 			return -ENODEV;
-		}
-		else {
+		} else {
 			rsw2_info(MSG_GEN, "Got phy_iface mode: %s (%d)\n", phy_modes(phy_port->phy_iface), phy_port->phy_iface);
 		}
 	}
@@ -3154,7 +3082,6 @@ static int rswitch2_init_physical_port(struct rswitch2_drv *rsw2, unsigned int p
 	port_ndev->base_addr = (unsigned long)rsw2->etha_base_addrs[port_num];
 	rsw2_dbg(MSG_GEN, "Phy port %d: rsw2->etha_base_addrs[%d] = 0x%px\n", port_num, port_num, rsw2->etha_base_addrs[port_num]);
 
-
 	/* FIXME */
 	port_ndev->irq = rsw2->rxtx_irqs[port_num];
 
@@ -3162,7 +3089,6 @@ static int rswitch2_init_physical_port(struct rswitch2_drv *rsw2, unsigned int p
 	phy_port->serdes_chan_addr = rsw2->serdes_base_addr
 			+ (RSW2_SERDES_CHANNEL_OFFSET * port_num);
 
-
 	strncpy(port_ndev->name, RSW2_NETDEV_BASENAME, sizeof(port_ndev->name) - sizeof(port_name) - 1);
 	port_name_len = snprintf(port_name, sizeof(port_name), "p%1u", eth_port->port_num-1);
 	strncat(port_ndev->name, port_name, port_name_len);
@@ -3213,7 +3139,6 @@ static int rswitch2_init_physical_port(struct rswitch2_drv *rsw2, unsigned int p
 		goto cleanup_phy_port;
 	}
 
-
 	/* Link Verification */
 	/* TODO CMARD: I'm not sure if this is the correct position. The link verification
 	 * is a feature to ask the far end MAC if it is pre-emption capable. But this can
@@ -3252,7 +3177,6 @@ static int rswitch2_init_physical_port(struct rswitch2_drv *rsw2, unsigned int p
 
 	rswitch2_port_set_mac_addr(port_ndev);
 
-
 #if 0
 	ret = rswitch2_phy_init(port_ndev, port_num);
 	if (ret != 0) {
@@ -3723,7 +3647,7 @@ int rswitch2_eth_init(struct rswitch2_drv *rsw2)
 	}
 
 	/* Request data IRQs */
-	for(cur_irq = 0; cur_irq < rsw2->num_of_rxtx_irqs; cur_irq++) {
+	for (cur_irq = 0; cur_irq < rsw2->num_of_rxtx_irqs; cur_irq++) {
 		ret = request_irq(rsw2->rxtx_irqs[cur_irq], rswitch2_eth_interrupt, IRQ_TYPE_LEVEL_HIGH,
 						RSWITCH2_NAME, rsw2);
 		if (ret < 0) {
@@ -3733,7 +3657,7 @@ int rswitch2_eth_init(struct rswitch2_drv *rsw2)
 	}
 
 	/* Request status IRQs */
-	for(cur_irq = 0; cur_irq < rsw2->num_of_status_irqs; cur_irq++) {
+	for (cur_irq = 0; cur_irq < rsw2->num_of_status_irqs; cur_irq++) {
 		ret = request_irq(rsw2->status_irqs[cur_irq], rswitch2_status_interrupt, IRQ_TYPE_LEVEL_HIGH,
 						RSWITCH2_NAME, rsw2);
 		if (ret < 0) {
@@ -3743,7 +3667,7 @@ int rswitch2_eth_init(struct rswitch2_drv *rsw2)
 	}
 
 	/* Set max frame size to enable data storage in internal RAM */
-	for( i = 0; i < 8; i++) {
+	for (i = 0; i < 8; i++) {
 		iowrite32(0xFFFF, rsw2->gwca_base_addrs[0] +RSW2_GCWA_GWRMFSC(i));
 	}
 
@@ -3776,10 +3700,10 @@ void rswitch2_eth_exit(struct rswitch2_drv *rsw2)
 	iowrite32(0xFF, rsw2->gwca_base_addrs[0] + RSW2_GCWA_GWRDQC);
 
 
-	for(cur_irq = 0; cur_irq < rsw2->num_of_rxtx_irqs; cur_irq++) {
+	for (cur_irq = 0; cur_irq < rsw2->num_of_rxtx_irqs; cur_irq++) {
 		free_irq(rsw2->rxtx_irqs[cur_irq], rsw2);
 	}
-	for(cur_irq = 0; cur_irq < rsw2->num_of_status_irqs; cur_irq++) {
+	for (cur_irq = 0; cur_irq < rsw2->num_of_status_irqs; cur_irq++) {
 		free_irq(rsw2->status_irqs[cur_irq], rsw2);
 	}
 
@@ -3798,17 +3722,17 @@ void rswitch2_eth_exit(struct rswitch2_drv *rsw2)
 		phy_port = eth_port->phy_port;
 
 		rtnl_lock();
-		if(netif_running(ndev))
+		if (netif_running(ndev))
 			dev_close(ndev);
 		rtnl_unlock();
 
 		if (phy_port) {
-            uint cur_q;
-            uint num_of_rx_queues;
-            uint num_of_tx_queues;
+			uint cur_q;
+			uint num_of_rx_queues;
+			uint num_of_tx_queues;
 
-            phy_disconnect(phy_port->phy);
-            phy_device_remove(phy_port->phy);
+			phy_disconnect(phy_port->phy);
+			phy_device_remove(phy_port->phy);
 			phy_device_free(phy_port->phy);
 
 			mdiobus_unregister(phy_port->mii_bus);
diff --git a/drivers/net/ethernet/renesas/rswitch2/rswitch2_fwd.c b/drivers/net/ethernet/renesas/rswitch2/rswitch2_fwd.c
index 66a8a0283a0c..d99efc03651d 100644
--- a/drivers/net/ethernet/renesas/rswitch2/rswitch2_fwd.c
+++ b/drivers/net/ethernet/renesas/rswitch2/rswitch2_fwd.c
@@ -11,57 +11,57 @@
 #include "rswitch2.h"
 #include "rswitch2_fwd.h"
 
-static int rsw2_fwd_find_free_cascade_filter_slot(struct rswitch2_drv *rsw2) {
+static int rsw2_fwd_find_free_cascade_filter_slot(struct rswitch2_drv *rsw2)
+{
 
 	u32 filter_conf;
 	uint slot_num;
 
-	for(slot_num = 0; slot_num < RSW2_FWD_THBF_N; slot_num++) {
+	for (slot_num = 0; slot_num < RSW2_FWD_THBF_N; slot_num++) {
 		filter_conf = ioread32(rsw2->fwd_base_addr + RSW2_FWD_FWCFC(slot_num));
 
-		if(filter_conf == 0) {
+		if (filter_conf == 0) {
 			rsw2_info(MSG_FWD, "Cascade filter slot %d is unused\n", slot_num);
 
 			break;
 		}
 	}
 
-	if(slot_num >= RSW2_FWD_THBF_N) {
+	if (slot_num >= RSW2_FWD_THBF_N) {
 		return -EFILTER_LIST_FULL;
 	}
 
-	return (int) slot_num;
+	return (int)slot_num;
 }
 
 
-static int rsw2_fwd_find_free_3byte_filter_slot(struct rswitch2_drv *rsw2) {
+static int rsw2_fwd_find_free_3byte_filter_slot(struct rswitch2_drv *rsw2)
+{
 	u32 filter_conf;
 	u32 filter_val0;
 	u32 filter_val1;
 	uint slot_num;
 
-	for(slot_num = 0; slot_num < RSW2_FWD_THBF_N; slot_num++) {
+	for (slot_num = 0; slot_num < RSW2_FWD_THBF_N; slot_num++) {
 		filter_conf = ioread32(rsw2->fwd_base_addr + RSW2_FWD_FWTHBFC(slot_num));
 		filter_val0 = ioread32(rsw2->fwd_base_addr + RSW2_FWD_FWTHBFV0C(slot_num));
 		filter_val1 = ioread32(rsw2->fwd_base_addr + RSW2_FWD_FWTHBFV1C(slot_num));
 
-		if((filter_conf == 0) && (filter_val0 == 0) && (filter_val1 == 0)) {
+		if ((filter_conf == 0) && (filter_val0 == 0) && (filter_val1 == 0)) {
 			//printk("3byte filter slot %d is unused\n", slot_num);
 
 			break;
 		}
 	}
 
-	if(slot_num >= RSW2_FWD_THBF_N) {
+	if (slot_num >= RSW2_FWD_THBF_N)
 		return -EFILTER_LIST_FULL;
-	}
-
 
-	return (int) slot_num;
+	return (int)slot_num;
 }
 
-static int rsw2_fwd_add_cascade_filter(struct rswitch2_drv *rsw2, struct cascade_filter *filter) {
-
+static int rsw2_fwd_add_cascade_filter(struct rswitch2_drv *rsw2, struct cascade_filter *filter)
+{
 	int ret;
 	u32 filter_conf;
 
@@ -69,9 +69,8 @@ static int rsw2_fwd_add_cascade_filter(struct rswitch2_drv *rsw2, struct cascade
 	uint filter_map_entry;
 
 	ret = rsw2_fwd_find_free_cascade_filter_slot(rsw2);
-	if(ret < 0) {
+	if (ret < 0)
 		return ret;
-	}
 
 	filter_slot = (uint)ret;
 	filter->stream_id = filter_slot;
@@ -79,7 +78,7 @@ static int rsw2_fwd_add_cascade_filter(struct rswitch2_drv *rsw2, struct cascade
 	filter_conf = FIELD_PREP(FWCFC_CFPFFV, filter->pframe_bitmap);
 	filter_conf |= FIELD_PREP(FWCFC_CFEFFV, filter->eframe_bitmap);
 
-	for(filter_map_entry = 0; filter_map_entry < RSW2_FWD_CFMF_N; filter_map_entry++) {
+	for (filter_map_entry = 0; filter_map_entry < RSW2_FWD_CFMF_N; filter_map_entry++) {
 		u32 reg_val;
 
 		reg_val = FIELD_PREP(FWCFMC_CFFV, filter->entry[filter_map_entry].enabled);
@@ -102,17 +101,15 @@ static int rsw2_fwd_add_3byte_filter(struct rswitch2_drv *rsw2, struct three_byt
 	uint filter_slot;
 
 	ret = rsw2_fwd_find_free_3byte_filter_slot(rsw2);
-	if(ret < 0) {
+	if (ret < 0)
 		return ret;
-	}
 
 	filter_slot = (uint)ret;
 
 	filter_conf = FIELD_PREP(FWTHBFC_THBFUM, filter->mode);
 	filter_conf |= FIELD_PREP(FWTHBFC_THBFOV, filter->offset);
 
-
-	switch(filter->mode) {
+	switch (filter->mode) {
 	case pf_mask_mode:
 		filter_val0  = FIELD_PREP(FWTHBFV0C_THBFV0B0, filter->m.val[2]);
 		filter_val0 |= FIELD_PREP(FWTHBFV0C_THBFV0B1, filter->m.val[1]);
@@ -156,7 +153,6 @@ static int rsw2_fwd_add_3byte_filter(struct rswitch2_drv *rsw2, struct three_byt
 		break;
 	}
 
-
 	iowrite32(filter_val0, rsw2->fwd_base_addr + RSW2_FWD_FWTHBFV0C(filter_slot));
 	iowrite32(filter_val1, rsw2->fwd_base_addr + RSW2_FWD_FWTHBFV1C(filter_slot));
 	iowrite32(filter_conf, rsw2->fwd_base_addr + RSW2_FWD_FWTHBFC(filter_slot));
@@ -164,8 +160,8 @@ static int rsw2_fwd_add_3byte_filter(struct rswitch2_drv *rsw2, struct three_byt
 	return ret;
 }
 
-static int rsw2_fwd_add_l3_entry(struct rswitch2_drv *rsw2, u32 stream_id, u32 src_port_vec, u32 dest_port_vec, u32 cpu_q) {
-
+static int rsw2_fwd_add_l3_entry(struct rswitch2_drv *rsw2, u32 stream_id, u32 src_port_vec, u32 dest_port_vec, u32 cpu_q)
+{
 	int ret;
 	u32 reg_val;
 
@@ -204,18 +200,17 @@ static int rsw2_fwd_add_l3_entry(struct rswitch2_drv *rsw2, u32 stream_id, u32 s
 	}
 
 	reg_val = ioread32(rsw2->fwd_base_addr + RSW2_FWD_FWLTHTLR);
-	if(FIELD_GET(FWLTHTLR_LTHLF, reg_val)) {
+	if (FIELD_GET(FWLTHTLR_LTHLF, reg_val)) {
 		/* FIXME: Check others error bits */
 		rsw2_err(MSG_FWD, "Learning failed\n");
-	}
-	else {
+	} else {
 		rsw2_info(MSG_FWD, "Learning succeeded\n");
 	}
 	return ret;
 }
 
-int rsw2_fwd_add_l2_entry(struct rswitch2_drv *rsw2, const u8 *macaddr, u32 src_port_vec, u32 dest_port_vec, u32 cpu_q) {
-
+int rsw2_fwd_add_l2_entry(struct rswitch2_drv *rsw2, const u8 *macaddr, u32 src_port_vec, u32 dest_port_vec, u32 cpu_q)
+{
 	int ret;
 	u32 reg_val;
 
@@ -256,12 +251,11 @@ int rsw2_fwd_add_l2_entry(struct rswitch2_drv *rsw2, const u8 *macaddr, u32 src_
 	return 0;
 }
 
-int rsw2_fwd_del_l2_entry(struct rswitch2_drv *rsw2, const u8 *macaddr) {
+int rsw2_fwd_del_l2_entry(struct rswitch2_drv *rsw2, const u8 *macaddr)
+{
 	int ret;
 	u32 reg_val;
 
-
-
 	reg_val = FIELD_PREP(FWMACTL0_MACED, 1);
 	iowrite32(reg_val, rsw2->fwd_base_addr + RSW2_FWD_FWMACTL0);
 
@@ -288,10 +282,6 @@ int rsw2_fwd_del_l2_entry(struct rswitch2_drv *rsw2, const u8 *macaddr) {
 	return 0;
 }
 
-
-
-
-
 int rswitch2_fwd_init(struct rswitch2_drv *rsw2)
 {
 	int cur_port;
@@ -301,7 +291,6 @@ int rswitch2_fwd_init(struct rswitch2_drv *rsw2)
 
 	/* Simple static forward configuration to allow access to internal port */
 
-
 	/* Enable access for both APBs */
 	/* TODO: Needs to be checked on S4 */
 	iowrite32(0xFFFFFFFF, rsw2->fwd_base_addr + RSW2_FWD_FWSCR27);
@@ -320,7 +309,6 @@ int rswitch2_fwd_init(struct rswitch2_drv *rsw2)
 	// FIXME: check if needed
 	reg_val |= FWPC0_L2SE;
 
-
 	for (cur_port = 0; cur_port < num_of_ports; cur_port++) {
 		iowrite32(reg_val, rsw2->fwd_base_addr + RSW2_FWD_FWPC0(cur_port));
 	}
@@ -403,7 +391,6 @@ int rswitch2_fwd_init(struct rswitch2_drv *rsw2)
 	}
 #endif
 
-
 	/* Configure aging */
 	reg_val = FIELD_PREP(FWMACAGUSP_MACAGUSP, 0x4E);
 	iowrite32(reg_val, rsw2->fwd_base_addr + RSW2_FWD_FWMACAGUSP);
@@ -472,7 +459,7 @@ int rswitch2_fwd_init(struct rswitch2_drv *rsw2)
 
 		memset(cc_filter, 0 , sizeof(cc_filter));
 
-		for( i = 0; i < 3; i++) {
+		for (i = 0; i < 3; i++) {
 			set_bit(i, &cc_filter[i].eframe_bitmap);
 			set_bit(i, &cc_filter[i].pframe_bitmap);
 
diff --git a/drivers/net/ethernet/renesas/rswitch2/rswitch2_main.c b/drivers/net/ethernet/renesas/rswitch2/rswitch2_main.c
index d6bdfa0d4485..ff82349b0d8a 100644
--- a/drivers/net/ethernet/renesas/rswitch2/rswitch2_main.c
+++ b/drivers/net/ethernet/renesas/rswitch2/rswitch2_main.c
@@ -109,7 +109,6 @@ int rswitch2_init(struct rswitch2_drv *rsw2)
 
 	rsw2_notice(MSG_GEN, "PTP clock initialized\n");
 
-
 	ret = rswitch2_fwd_init(rsw2);
 	if (ret < 0)
 		goto err_fwd_init;
diff --git a/drivers/net/ethernet/renesas/rswitch2/rswitch2_platf.c b/drivers/net/ethernet/renesas/rswitch2/rswitch2_platf.c
index 0451949ffbcb..af0658e05d64 100644
--- a/drivers/net/ethernet/renesas/rswitch2/rswitch2_platf.c
+++ b/drivers/net/ethernet/renesas/rswitch2/rswitch2_platf.c
@@ -88,8 +88,6 @@ static int rswitch2_mii_reset(struct mii_bus *bus)
 	return 0;
 }
 
-
-
 /* FIXME: Per Port!!! */
 static int rswitch2_register_mii_bus(struct rswitch2_drv *rsw2)
 {
@@ -126,8 +124,6 @@ static int rswitch2_register_mii_bus(struct rswitch2_drv *rsw2)
 }
 #endif
 
-
-
 static void rswitch2_platf_set_base_addr(struct rswitch2_drv *rsw2)
 {
 	u8 __iomem *base_addr = rsw2->base_addr;
@@ -155,15 +151,13 @@ static int rswitch2_platf_request_irqs(struct rswitch2_drv *rsw2)
 	int irq;
 	int ret;
 
-
 	pdev = container_of(rsw2->dev, struct platform_device, dev);
 
 	dn_irqs = of_get_property(rsw2->dev->of_node, "interrupt-names", &dt_prop_len);
 	if (!dn_irqs) {
 		rsw2_err(MSG_GEN, "No irqs specified in device tree\n");
 		return -EINVAL;
-	}
-	else {
+	} else {
 		rsw2_dbg(MSG_GEN, "Got irq array of len %d  from device tree nodes\n", dt_prop_len);
 	}
 
@@ -172,7 +166,6 @@ static int rswitch2_platf_request_irqs(struct rswitch2_drv *rsw2)
 	if (!irq_names)
 		return -ENOMEM;
 
-
 	ret = of_property_read_string_array(rsw2->dev->of_node, "interrupt-names",
 			irq_names, RSWITCH2_MAX_IRQS);
 	if (ret < 0)
@@ -180,7 +173,7 @@ static int rswitch2_platf_request_irqs(struct rswitch2_drv *rsw2)
 
 	dt_max_irqs = (unsigned int)ret;
 
-	for(dt_cur_irq = 0; dt_cur_irq < dt_max_irqs; dt_cur_irq++) {
+	for (dt_cur_irq = 0; dt_cur_irq < dt_max_irqs; dt_cur_irq++) {
 		size_t prop_str_len;
 
 		prop_str_len = strlen(irq_names[dt_cur_irq]);
@@ -188,7 +181,7 @@ static int rswitch2_platf_request_irqs(struct rswitch2_drv *rsw2)
 		rsw2_info(MSG_GEN, "Got irq #%.02d '%s'\n", dt_cur_irq, irq_names[dt_cur_irq]);
 
 		/* FIXME: Check if DT string is shorter than sizeof(RSW2_GWCA0_NAME) - 1 */
-		if(prop_str_len > sizeof(RSW2_GWCA0_NAME)) {
+		if (prop_str_len > sizeof(RSW2_GWCA0_NAME)) {
 
 			ret = strncmp(irq_names[dt_cur_irq], RSW2_GWCA0_NAME, sizeof(RSW2_GWCA0_NAME) - 1);
 			if(ret == 0) {
@@ -202,9 +195,9 @@ static int rswitch2_platf_request_irqs(struct rswitch2_drv *rsw2)
 				rsw2_dbg(MSG_GEN, "Got irq %d '%s' from DT index %d\n", irq, irq_names[dt_cur_irq], dt_cur_irq);
 
 				ret = strncmp(irq_type_str, "rxtx", 4);
-				if(ret == 0) {
+				if (ret == 0) {
 					rsw2_info(MSG_GEN, "Registering RXTX irq #%.02d '%s'\n", dt_cur_irq, irq_names[dt_cur_irq]);
-					if(rsw2->num_of_rxtx_irqs >=  RSWITCH2_MAX_RXTX_IRQS) {
+					if (rsw2->num_of_rxtx_irqs >=  RSWITCH2_MAX_RXTX_IRQS) {
 						rsw2_err(MSG_GEN, "Too many RXTX interrupts\n");
 						// FIXME: free memory
 						return -EINVAL;
@@ -212,9 +205,7 @@ static int rswitch2_platf_request_irqs(struct rswitch2_drv *rsw2)
 					}
 					rsw2->rxtx_irqs[rsw2->num_of_rxtx_irqs] = irq;
 					rsw2->num_of_rxtx_irqs++;
-
-				}
-				else {
+				} else {
 					rsw2_info(MSG_GEN, "Registering status irq #%.02d '%s'\n", dt_cur_irq, irq_names[dt_cur_irq]);
 					if(rsw2->num_of_status_irqs >=  RSWITCH2_MAX_STATUS_IRQS) {
 						rsw2_err(MSG_GEN, "Too many status interrupts\n");
@@ -224,7 +215,6 @@ static int rswitch2_platf_request_irqs(struct rswitch2_drv *rsw2)
 					}
 					rsw2->status_irqs[rsw2->num_of_status_irqs] = irq;
 					rsw2->num_of_status_irqs++;
-
 				}
 			}
 		}
@@ -247,7 +237,7 @@ static phy_interface_t rswitch2_get_phy_inferface(const char *phy_mode_str) {
 	phy_interface_t intf = PHY_INTERFACE_MODE_NA;
 	const int elem = ARRAY_SIZE(rsw2_phy_mode_xlate_tbl);
 
-	for(i = 0; i < elem; i++) {
+	for (i = 0; i < elem; i++) {
 		int ret;
 		ret = strcmp(phy_mode_str, rsw2_phy_mode_xlate_tbl[i].dt_str);
 		//printk("Comparing '%s' <-> '%s'\n", phy_mode_str, rsw2_phy_mode_xlate_tbl[i].dt_str);
@@ -272,11 +262,9 @@ static int rswitch2_platf_set_port_data(struct rswitch2_drv *rsw2)
 
 	int ret = 0;
 
-
 	pdev = container_of(rsw2->dev, struct platform_device, dev);
 	rsw2_dbg(MSG_GEN, "rswitch2_platf_set_port_data(): pdev is at 0x%px\n", pdev);
 
-
 	//total_ports = rsw2->num_of_cpu_ports + rsw2->num_of_tsn_ports;
 #ifdef  RSW2_DEPRECATED
 	rsw2->port_data = kcalloc(total_ports, sizeof(*cur_port_data), GFP_KERNEL);
@@ -331,8 +319,6 @@ static int rswitch2_platf_set_port_data(struct rswitch2_drv *rsw2)
 						"e6800000.ethernet-ffffffff", 0x00);
 	pr_info("Port 3 PHY ID: '%s'\n", cur_port_data->phy_id);
 
-
-
 	ports = of_get_child_by_name(rsw2->dev->of_node, "ports");
 	if (!ports) {
 		dev_err(rsw2->dev, "No ports specified in device tree\n");
@@ -344,16 +330,14 @@ static int rswitch2_platf_set_port_data(struct rswitch2_drv *rsw2)
 
 
 	dt_port_num = of_get_child_count(ports);
-	if(dt_port_num > rsw2->num_of_tsn_ports) {
+	if (dt_port_num > rsw2->num_of_tsn_ports) {
 		dev_err(rsw2->dev, "%d ports specified in device tree, but maximum %d ports supported.\n",
 				dt_port_num, rsw2->num_of_tsn_ports);
 		return -EINVAL;
-	}
-	else {
+	} else {
 		dev_info(rsw2->dev, "DT specifies %d Ethernet ports\n", dt_port_num);
 	}
 
-
 	cur_port_num = 0;
 
 	for_each_child_of_node(ports, port) {
@@ -396,7 +380,6 @@ static int rswitch2_platf_set_port_data(struct rswitch2_drv *rsw2)
 	return ret;
 }
 
-
 static int rswitch2_platf_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -414,7 +397,6 @@ static int rswitch2_platf_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-
 	drv_priv = devm_kzalloc(&pdev->dev, sizeof(*drv_priv), GFP_KERNEL);
 	if (!drv_priv) {
 		return -ENOMEM;
@@ -514,7 +496,6 @@ static int rswitch2_platf_probe(struct platform_device *pdev)
 
 	rsw2_dbg(MSG_GEN,"pdev->dev.power.disable_depth:: %d\n", pdev->dev.power.disable_depth);
 
-
 	device_set_wakeup_capable(&pdev->dev, 1);
 
 	/* Init RSwitch2 core */
@@ -548,17 +529,14 @@ static int rswitch2_platf_probe(struct platform_device *pdev)
 }
 
 /* Clean up */
-//static void rswitch2_pci_remove(struct pci_dev *pdev)
 static int rswitch2_platf_remove(struct platform_device *pdev)
 {
 	struct rswitch2_platf_driver_priv *drv_priv = platform_get_drvdata(pdev);
 
-
 	if (drv_priv) {
 		if (drv_priv->rsw2) {
 			struct rswitch2_drv *rsw2 = drv_priv->rsw2;
 
-
 			rswitch2_exit(drv_priv->rsw2);
 
 			rswitch2_platf_release_irqs(drv_priv->rsw2);
@@ -583,7 +561,6 @@ static int rswitch2_platf_remove(struct platform_device *pdev)
 			kfree(drv_priv->rsw2);
 		}
 
-
 		devm_kfree(&pdev->dev, drv_priv);
 		platform_set_drvdata(pdev, NULL);
 	}
@@ -683,7 +660,6 @@ static const struct of_device_id rswitch2_platf_of_table[] = {
 };
 MODULE_DEVICE_TABLE(of, rswitch2_platf_of_table);
 
-
 static struct platform_driver rswitch2_platf_drv = {
 	.probe = rswitch2_platf_probe,
 	.remove = rswitch2_platf_remove,
-- 
2.39.2

