From 66506cb1a899dbe8a791fd122f9a9fa40476d778 Mon Sep 17 00:00:00 2001
From: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
Date: Sat, 28 Oct 2023 13:05:00 +0600
Subject: [PATCH 76/85] net: phy: split phy_create() into initialize and
 assign_ids steps

Read of phy registers may be not possible while phy is in reset.

The split makes it possible for callers to parse the reset configuration
and make phy_device_reset() operational before reading phy ids.

Signed-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
---
 drivers/net/phy/phy_device.c | 94 ++++++++++++++++++++++--------------
 include/linux/phy.h          |  3 ++
 2 files changed, 62 insertions(+), 35 deletions(-)

diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 49918d6770e0..f7d4ee14ad0d 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -577,53 +577,61 @@ static int phy_request_driver_module(struct phy_device *dev, u32 phy_id)
 	return 0;
 }
 
-struct phy_device *phy_device_create(struct mii_bus *bus, int addr, u32 phy_id,
-				     bool is_c45,
-				     struct phy_c45_device_ids *c45_ids)
+struct phy_device *phy_device_initialize(struct mii_bus *bus, int addr)
 {
-	struct phy_device *dev;
+	struct phy_device *phydev;
 	struct mdio_device *mdiodev;
-	int ret = 0;
+	struct device *dev;
 
 	/* We allocate the device, and initialize the default values */
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev)
+	phydev = kzalloc(sizeof(*phydev), GFP_KERNEL);
+	if (!phydev)
 		return ERR_PTR(-ENOMEM);
+	mdiodev = &phydev->mdio;
+	dev = &mdiodev->dev;
+
+	dev_set_name(dev, PHY_ID_FMT, bus->id, addr);
+	dev->parent = &bus->dev;
+	dev->bus = &mdio_bus_type;
+	dev->type = &mdio_bus_phy_type;
+	device_initialize(dev);
 
-	mdiodev = &dev->mdio;
-	mdiodev->dev.parent = &bus->dev;
-	mdiodev->dev.bus = &mdio_bus_type;
-	mdiodev->dev.type = &mdio_bus_phy_type;
 	mdiodev->bus = bus;
-	mdiodev->bus_match = phy_bus_match;
 	mdiodev->addr = addr;
 	mdiodev->flags = MDIO_DEVICE_FLAG_PHY;
 	mdiodev->device_free = phy_mdio_device_free;
 	mdiodev->device_remove = phy_mdio_device_remove;
 
-	dev->speed = SPEED_UNKNOWN;
-	dev->duplex = DUPLEX_UNKNOWN;
-	dev->pause = 0;
-	dev->asym_pause = 0;
-	dev->link = 0;
-	dev->port = PORT_TP;
-	dev->interface = PHY_INTERFACE_MODE_GMII;
+	phydev->speed = SPEED_UNKNOWN;
+	phydev->duplex = DUPLEX_UNKNOWN;
+	phydev->autoneg = AUTONEG_ENABLE;
+	phydev->state = PHY_DOWN;
+	phydev->pause = 0;
+	phydev->asym_pause = 0;
+	phydev->link = 0;
+	phydev->port = PORT_TP;
+	phydev->interface = PHY_INTERFACE_MODE_GMII;
 
-	dev->autoneg = AUTONEG_ENABLE;
+	phydev->irq = bus->irq[addr];
 
-	dev->is_c45 = is_c45;
-	dev->phy_id = phy_id;
-	if (c45_ids)
-		dev->c45_ids = *c45_ids;
-	dev->irq = bus->irq[addr];
+	mutex_init(&phydev->lock);
+	INIT_DELAYED_WORK(&phydev->state_queue, phy_state_machine);
 
-	dev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr);
-	device_initialize(&mdiodev->dev);
+	return phydev;
+}
+EXPORT_SYMBOL(phy_device_initialize);
 
-	dev->state = PHY_DOWN;
+int phy_device_assign_ids(struct phy_device *phydev, u32 phy_id, bool is_c45,
+			  struct phy_c45_device_ids *c45_ids)
+{
+	struct mdio_device *mdiodev = &phydev->mdio;
+	int ret = 0;
 
-	mutex_init(&dev->lock);
-	INIT_DELAYED_WORK(&dev->state_queue, phy_state_machine);
+	phydev->is_c45 = is_c45;
+	phydev->phy_id = phy_id;
+	if (c45_ids)
+		phydev->c45_ids = *c45_ids;
+	mdiodev->bus_match = phy_bus_match;
 
 	/* Request the appropriate module unconditionally; don't
 	 * bother trying to do so only if it isn't already loaded,
@@ -643,21 +651,37 @@ struct phy_device *phy_device_create(struct mii_bus *bus, int addr, u32 phy_id,
 			if (c45_ids->device_ids[i] == 0xffffffff)
 				continue;
 
-			ret = phy_request_driver_module(dev,
+			ret = phy_request_driver_module(phydev,
 						c45_ids->device_ids[i]);
 			if (ret)
 				break;
 		}
 	} else {
-		ret = phy_request_driver_module(dev, phy_id);
+		ret = phy_request_driver_module(phydev, phy_id);
 	}
 
+	return ret;
+}
+EXPORT_SYMBOL(phy_device_assign_ids);
+
+struct phy_device *phy_device_create(struct mii_bus *bus, int addr, u32 phy_id,
+				     bool is_c45,
+				     struct phy_c45_device_ids *c45_ids)
+{
+	struct phy_device *phydev;
+	int ret = 0;
+
+	phydev = phy_device_initialize(bus, addr);
+	if (IS_ERR(phydev))
+		return phydev;
+
+	ret = phy_device_assign_ids(phydev, phy_id, is_c45, c45_ids);
 	if (ret) {
-		put_device(&mdiodev->dev);
-		dev = ERR_PTR(ret);
+		phy_device_free(phydev);
+		return ERR_PTR(ret);
 	}
 
-	return dev;
+	return phydev;
 }
 EXPORT_SYMBOL(phy_device_create);
 
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 08725a262f32..c80aabace61f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1346,6 +1346,9 @@ int phy_modify_paged_changed(struct phy_device *phydev, int page, u32 regnum,
 int phy_modify_paged(struct phy_device *phydev, int page, u32 regnum,
 		     u16 mask, u16 set);
 
+struct phy_device *phy_device_initialize(struct mii_bus *bus, int addr);
+int phy_device_assign_ids(struct phy_device *dev, u32 phy_id, bool is_c45,
+			  struct phy_c45_device_ids *c45_ids);
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, u32 phy_id,
 				     bool is_c45,
 				     struct phy_c45_device_ids *c45_ids);
-- 
2.39.2

