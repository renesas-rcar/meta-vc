From e0654558ea3404458bc4ab975e9426c5ac216a0e Mon Sep 17 00:00:00 2001
From: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
Date: Mon, 22 May 2023 11:16:26 +0600
Subject: [PATCH 14/92] clk: renesas: control domain clocks support

This commit adds partial support for control domain clocks:
- reading rates for some control domain clocks,
- enabling/disabling control domain MSSR clocks.

The location of the control domain clock registers must be defined in
the second 'reg' entry for the clock controller. If the second 'reg'
entry is not defined, no control domain clocks are registered.

Setup for control domain clocks other than enablng/disabling MSSR bits
is intentionally kept read only. Control domain clock configuration is
assumed to be done before Linux starts.

Clients can use control domain MSSR clocks by
	clocks = <&cpg CPG_CD_MOD 600>;

Each MSSR clock shall be defined (for S4) in r8a779f0-cpg-mssr.c in
r8a779f0_cd_mod_clks[] table. The numeric ID is composed from MSR_*
register index in r8a779f0_cd_mod_control_regs[] table, and bit number
inside that register. This commits defines some MSSR clocks, but not
all of them.

Signed-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
---
 drivers/clk/renesas/r8a779f0-cpg-mssr.c       | 239 +++++++++++++++++-
 drivers/clk/renesas/renesas-cpg-mssr.c        | 204 ++++++++++++++-
 drivers/clk/renesas/renesas-cpg-mssr.h        |  13 +
 drivers/soc/renesas/rcar-rst.c                |  19 ++
 include/dt-bindings/clock/r8a779f0-cpg-mssr.h |   4 +
 include/dt-bindings/clock/renesas-cpg-mssr.h  |   1 +
 include/linux/soc/renesas/rcar-rst.h          |   1 +
 7 files changed, 478 insertions(+), 3 deletions(-)

diff --git a/drivers/clk/renesas/r8a779f0-cpg-mssr.c b/drivers/clk/renesas/r8a779f0-cpg-mssr.c
index 964b985ac926..951e62f1217c 100644
--- a/drivers/clk/renesas/r8a779f0-cpg-mssr.c
+++ b/drivers/clk/renesas/r8a779f0-cpg-mssr.c
@@ -25,9 +25,20 @@
 #include "renesas-cpg-mssr.h"
 #include "rcar-gen4-cpg.h"
 
+enum r8a779f0_clk_types {
+	CLK_TYPE_CD_FIRST = CLK_TYPE_GEN4_SOC_BASE,
+	CLK_TYPE_CD_MOSC = CLK_TYPE_CD_FIRST,
+	CLK_TYPE_CD_PLL,
+	CLK_TYPE_CD_PLLO,
+	CLK_TYPE_CD_SYS,
+	CLK_TYPE_CD_UHSB,
+	CLK_TYPE_CD_CANFD,
+	CLK_TYPE_CD_MSPI,
+};
+
 enum clk_ids {
 	/* Core Clock Outputs exported to DT */
-	LAST_DT_CORE_CLK = R8A779F0_CLK_OSC,
+	LAST_DT_CORE_CLK = R8A779F0_LAST_CORE_CLK,
 
 	/* External Input Clocks */
 	CLK_EXTAL,
@@ -51,6 +62,18 @@ enum clk_ids {
 	CLK_RPCSRC,
 	CLK_OCO,
 
+	CD_CLK_MOSC,
+	CD_CLK_HSIOSC,
+	CD_CLK_LSIOSC,
+	CD_CLK_HVIOSC,
+	CD_CLK_PLL,
+	CD_CLK_PLLO,
+	CD_CLK_IOSC,
+	CD_CLK_SYS,
+	CD_CLK_UHSB,
+	CD_CLK_HSB,
+	CD_CLK_LSB,
+
 	/* Module Clocks */
 	MOD_CLK_BASE
 };
@@ -125,6 +148,38 @@ static const struct cpg_core_clk r8a779f0_core_clks[] __initconst = {
 
 	DEF_GEN4_OSC("osc",	R8A779F0_CLK_OSC,	CLK_EXTAL,	8),
 	DEF_GEN4_MDSEL("r",	R8A779F0_CLK_R, 29, CLK_EXTALR, 1, CLK_OCO, 1),
+
+	/* Control domain internal clocks */
+
+	/* rate of CLK_MOSC is fixed, depends on MD 14:13 */
+	DEF_TYPE("cd_mosc",	CD_CLK_MOSC,	CLK_TYPE_CD_MOSC),
+
+	/* rates of CLK_HSIOSC, CLK_LSIOSC, CLK_HVIOSC are fixed */
+	DEF_RATE("cd_hsiosc",	CD_CLK_HSIOSC,	200 * 1000 * 1000),
+	DEF_RATE("cd_lsiosc",	CD_CLK_LSIOSC,	240 * 1000),
+	DEF_RATE("cd_hviosc",	CD_CLK_HVIOSC,	4 * 1000 * 1000),
+
+	/* rate of CLK_PLL is fixed, depends om MD 40:39 */
+	DEF_TYPE("cd_pll",	CD_CLK_PLL,	CLK_TYPE_CD_PLL),
+
+	/* CLK_PLLO is divided from CLK_PLL */
+	DEF_TYPE("cd_pllo",	CD_CLK_PLLO,	CLK_TYPE_CD_PLLO),
+
+	/* CLK_IOSC sourced from CLK_HSIOSC unless that is stopped, which
+	 * happens only in complex standby modes */
+	DEF_FIXED("cd_iosc",	CD_CLK_IOSC,	CD_CLK_HSIOSC, 1, 1),
+
+	/* CLK_SYS sourced from either CLK_PLLO or CLK_IOSC */
+	DEF_TYPE("cd_sys",	CD_CLK_SYS,	CLK_TYPE_CD_SYS),
+
+	/* CLK_UHSB / CLK_HSB / CLK_LSB defined per Table 13.6 */
+	DEF_TYPE("cd_uhsb",	CD_CLK_UHSB,	CLK_TYPE_CD_UHSB),
+	DEF_FIXED("cd_hsb",	CD_CLK_HSB,	CD_CLK_UHSB, 2, 1),
+	DEF_FIXED("cd_lsb",	CD_CLK_LSB,	CD_CLK_UHSB, 4, 1),
+
+	/* Control domain clock outputs */
+	DEF_TYPE("cd_canfd",	R8A779F0_CLK_CD_CANFD,	CLK_TYPE_CD_CANFD),
+	DEF_TYPE("cd_mspi",	R8A779F0_CLK_CD_MSPI,	CLK_TYPE_CD_MSPI),
 };
 
 static const struct mssr_mod_clk r8a779f0_mod_clks[] __initconst = {
@@ -189,6 +244,35 @@ static const struct mssr_mod_clk r8a779f0_mod_clks[] __initconst = {
 	DEF_MOD("thermal",      919,    R8A779F0_CLK_CL16M),
 };
 
+static const u16 r8a779f0_cd_mod_control_regs[] = {
+	0x1000,		/* 0 = MSR_RSCFD */
+	0x1010,		/* 1 = MSR_FLXA */
+	0x1030,		/* 2 = MSR_ETNB */
+	0x1040,		/* 3 = MSR_RSENT */
+	0x1050,		/* 4 = MSR_MSPI */
+	0x1060,		/* 5 = MSR_RLIN3 */
+	0x10f0,		/* 6 = MSR_RIIC */
+	0x1130,		/* 7 = MSR_TAUD */
+	0x1140,		/* 8 = MSR_TAUJ_ISO */
+	0x1180,		/* 9 = MSR_OSTM */
+};
+
+static const struct mssr_mod_clk r8a779f0_cd_mod_clks[] __initconst = {
+	/* Note: CD_CLK_HSB as canfd parent corresponds to "CANFD internal stable
+	 * clock" (and not 'clk_xincan' bypass) */
+	DEF_CD_MOD("rscfd0",	0,	CD_CLK_HSB),
+	DEF_CD_MOD("rscfd1",	1,	CD_CLK_HSB),
+	DEF_CD_MOD("etnb0",	200,	CD_CLK_HSB),
+	DEF_CD_MOD("mspi0",	400,	CD_CLK_HSB),
+	DEF_CD_MOD("mspi1",	401,	CD_CLK_HSB),
+	DEF_CD_MOD("mspi2",	402,	CD_CLK_HSB),
+	DEF_CD_MOD("mspi3",	403,	CD_CLK_HSB),
+	DEF_CD_MOD("mspi4",	404,	CD_CLK_HSB),
+	DEF_CD_MOD("mspi5",	405,	CD_CLK_HSB),
+	DEF_CD_MOD("riic0",	600,	CD_CLK_LSB),
+	DEF_CD_MOD("ostm0",	900,	CD_CLK_HSB),
+};
+
 /*
  * CPG Clock Data
  */
@@ -231,6 +315,151 @@ static int __init r8a779f0_cpg_mssr_init(struct device *dev)
 	return rcar_gen4_cpg_init(cpg_pll_config, CLK_EXTALR, cpg_mode);
 }
 
+#define CLKD_PLLC_OFFSET		0x120
+#define PLLO_DIV_SHIFT			0
+#define PLLO_DIV_WIDTH			3
+#define PLLO_PARENT			"cd_pll"
+static const struct clk_div_table pllo_div_table[] = {
+	{ .val = 1, .div = 1 },
+	{ .val = 2, .div = 2 },
+	{}
+};
+
+#define CLKC_CPUS_OFFSET		0x108
+#define SYS_PARENT_SHIFT		0
+#define SYS_PARENT_WIDTH		1
+static const char * const sys_parents[] = { "cd_pllo", "cd_iosc" };
+
+#define CLKC_RCANS_OFFSET		0x158
+#define RCAN_DIV_SHIFT			0
+#define RCAN_DIV_WIDTH			2
+#define RCAN_PARENT			"cd_mosc"
+static const struct clk_div_table rcan_div_table[] = {
+	{ .val = 1, .div = 1 },
+	{ .val = 2, .div = 2 },
+	{ .val = 3, .div = 4 },
+	{}
+};
+
+#define CLKC_MSPIS_OFFSET		0x178
+#define MSPI_PARENT_SHIFT		0
+#define MSPI_PARENT_WIDTH		1
+static const char * const mspi_parents[] = { "cd_mosc", "cd_hsb" };
+
+static struct clk * __init r8a779f0_cpg_clk_register(struct device *dev,
+	const struct cpg_core_clk *core, const struct cpg_mssr_info *info,
+	struct clk **clks, void __iomem *base,
+	struct raw_notifier_head *notifiers)
+{
+	u64 mode_pins;
+	int md_bits;
+	int error;
+	unsigned long rate;
+	int div;
+
+	switch (core->type) {
+	case CLK_TYPE_CD_MOSC:
+		error = rcar_rst_read_mode_pins_64(&mode_pins);
+		if (error)
+			return ERR_PTR(error);
+		md_bits = (mode_pins >> 13) & 3;
+		switch (md_bits) {
+		case 0:
+			rate = 16 * 1000 * 1000;
+			break;
+		case 1:
+			rate = 20 * 1000 * 1000;
+			break;
+		case 3:
+			rate = 40 * 1000 * 1000;
+			break;
+		default:
+			dev_err(dev, "Prohibited setting: md 14:13 is %d\n",
+					md_bits);
+			return ERR_PTR(-EINVAL);
+		}
+		return clk_register_fixed_rate(NULL, core->name, NULL, 0, rate);
+
+	case CLK_TYPE_CD_PLL:
+		error = rcar_rst_read_mode_pins_64(&mode_pins);
+		if (error)
+			return ERR_PTR(error);
+		md_bits = (mode_pins >> 39) & 3;
+		switch (md_bits) {
+		case 3:
+			rate = 800 * 1000 * 1000;
+			break;
+		case 2:
+			rate = 640 * 1000 * 1000;
+			break;
+		default:
+			rate = 480 * 1000 * 1000;
+			break;
+		}
+		return clk_register_fixed_rate(NULL, core->name, NULL, 0, rate);
+
+	case CLK_TYPE_CD_PLLO:
+		return clk_register_divider_table(NULL, core->name,
+				PLLO_PARENT, 0,
+				cpg_mssr_cd_base(dev) + CLKD_PLLC_OFFSET,
+				PLLO_DIV_SHIFT, PLLO_DIV_WIDTH,
+				CLK_DIVIDER_READ_ONLY,
+				pllo_div_table, NULL);
+
+	case CLK_TYPE_CD_SYS:
+		return clk_register_mux(NULL, core->name,
+				sys_parents, ARRAY_SIZE(sys_parents), 0,
+				cpg_mssr_cd_base(dev) + CLKC_CPUS_OFFSET,
+				SYS_PARENT_SHIFT, SYS_PARENT_WIDTH,
+				CLK_MUX_READ_ONLY, NULL);
+
+	case CLK_TYPE_CD_UHSB:
+		if (ioread32(cpg_mssr_cd_base(dev) + CLKC_CPUS_OFFSET) & 1) {
+			/* CLK_SYS sourced from CLK_IOSC - divider depends
+			 * on MD 40:39 */
+			error = rcar_rst_read_mode_pins_64(&mode_pins);
+			if (error)
+				return ERR_PTR(error);
+			md_bits = (mode_pins >> 39) & 3;
+			switch (md_bits) {
+			case 3:
+				div = 5;	/* 200 -> 40 */
+				break;
+			case 2:
+				div = 4;	/* 200 -> 50 */
+				break;
+			default:
+				div = 3;	/* 200 -> 66.67 */
+				break;
+			}
+		} else {
+			/* CLK_SYS sourced from CLK_PLLO - divider is 5 */
+			div = 5;
+		}
+		return clk_register_fixed_factor(NULL, core->name,
+					"cd_sys", 0, 1, div);
+
+	case CLK_TYPE_CD_CANFD:
+		return clk_register_divider_table(NULL, core->name,
+				RCAN_PARENT, 0,
+				cpg_mssr_cd_base(dev) + CLKC_RCANS_OFFSET,
+				RCAN_DIV_SHIFT, RCAN_DIV_WIDTH,
+				CLK_DIVIDER_READ_ONLY,
+				rcan_div_table, NULL);
+
+	case CLK_TYPE_CD_MSPI:
+		return clk_register_mux(NULL, core->name,
+				mspi_parents, ARRAY_SIZE(mspi_parents), 0,
+				cpg_mssr_cd_base(dev) + CLKC_MSPIS_OFFSET,
+				MSPI_PARENT_SHIFT, MSPI_PARENT_WIDTH,
+				CLK_MUX_READ_ONLY, NULL);
+
+	default:
+		return rcar_gen4_cpg_clk_register(dev, core, info, clks, base,
+				notifiers);
+	}
+}
+
 const struct cpg_mssr_info r8a779f0_cpg_mssr_info __initconst = {
 	/* Core Clocks */
 	.core_clks = r8a779f0_core_clks,
@@ -243,9 +472,15 @@ const struct cpg_mssr_info r8a779f0_cpg_mssr_info __initconst = {
 	.num_mod_clks = ARRAY_SIZE(r8a779f0_mod_clks),
 	.num_hw_mod_clks = 24 * 32,
 
+	/* Control domain module clocks */
+	.cd_mod_control_regs = r8a779f0_cd_mod_control_regs,
+	.num_cd_mod_control_regs = ARRAY_SIZE(r8a779f0_cd_mod_control_regs),
+	.cd_mod_clks = r8a779f0_cd_mod_clks,
+	.num_cd_mod_clks = ARRAY_SIZE(r8a779f0_cd_mod_clks),
+
 	/* Callbacks */
 	.init = r8a779f0_cpg_mssr_init,
-	.cpg_clk_register = rcar_gen4_cpg_clk_register,
+	.cpg_clk_register = r8a779f0_cpg_clk_register,
 
 	.reg_layout = CLK_REG_LAYOUT_RCAR_GEN4,
 };
diff --git a/drivers/clk/renesas/renesas-cpg-mssr.c b/drivers/clk/renesas/renesas-cpg-mssr.c
index 5632620cc36c..38aff783b576 100644
--- a/drivers/clk/renesas/renesas-cpg-mssr.c
+++ b/drivers/clk/renesas/renesas-cpg-mssr.c
@@ -172,6 +172,10 @@ struct cpg_mssr_priv {
 		u32 val;
 	} smstpcr_saved[ARRAY_SIZE(mstpsr_for_gen4)];
 
+	void __iomem *cd_base;
+	unsigned int num_cd_mod_clks;
+	const u16 *cd_mod_control_regs;
+
 	struct clk *clks[];
 };
 
@@ -277,6 +281,85 @@ static const struct clk_ops cpg_mstp_clock_ops = {
 	.is_enabled = cpg_mstp_clock_is_enabled,
 };
 
+static int cpg_cd_mstp_get_reg(struct clk_hw *hw,
+		void __iomem **out_reg, u32 *out_mask)
+{
+	struct mstp_clock *clock = to_mstp_clock(hw);
+	struct cpg_mssr_priv *priv = clock->priv;
+
+	if (!priv->cd_base)
+		return -ENXIO;
+	if (clock->index >= priv->num_cd_mod_clks)
+		return -EINVAL;
+
+	*out_reg = priv->cd_base + priv->cd_mod_control_regs[clock->index / 32];
+	*out_mask = BIT(clock->index % 32);
+	return 0;
+}
+
+static int cpg_cd_mstp_clock_endisable(struct clk_hw *hw, bool enable)
+{
+	struct cpg_mssr_priv *priv = to_mstp_clock(hw)->priv;
+	void __iomem *reg;
+	u32 mask, val;
+	unsigned long flags;
+	int ret;
+
+	ret = cpg_cd_mstp_get_reg(hw, &reg, &mask);
+	if (WARN_ON_ONCE(ret))
+		return ret;
+
+	spin_lock_irqsave(&priv->rmw_lock, flags);
+
+	/* Hardcode unlock for now */
+	writel(0xa5a5a501, priv->cd_base + 0x1710);
+
+	val = readl(reg);
+	if (enable)
+		val &= ~mask;	/* enable = clear bit */
+	else
+		val |= mask;
+	writel(val, reg);
+
+	(void)readl(reg);	/* flush write */
+
+	/* Hardcode lock for now */
+	writel(0xa5a5a500, priv->cd_base + 0x1710);
+
+	spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+	return 0;
+}
+
+static int cpg_cd_mstp_clock_enable(struct clk_hw *hw)
+{
+	return cpg_cd_mstp_clock_endisable(hw, true);
+}
+
+static void cpg_cd_mstp_clock_disable(struct clk_hw *hw)
+{
+	cpg_cd_mstp_clock_endisable(hw, false);
+}
+
+static int cpg_cd_mstp_clock_is_enabled(struct clk_hw *hw)
+{
+	void __iomem *reg;
+	u32 mask;
+	int ret;
+
+	ret = cpg_cd_mstp_get_reg(hw, &reg, &mask);
+	if (WARN_ON_ONCE(ret))
+		return 0;
+
+	return !(readl(reg) & mask);	/* bit set = disabled */
+}
+
+static const struct clk_ops cpg_cd_mstp_clock_ops = {
+	.enable = cpg_cd_mstp_clock_enable,
+	.disable = cpg_cd_mstp_clock_disable,
+	.is_enabled = cpg_cd_mstp_clock_is_enabled,
+};
+
 static
 struct clk *cpg_mssr_clk_src_twocell_get(struct of_phandle_args *clkspec,
 					 void *data)
@@ -317,6 +400,23 @@ struct clk *cpg_mssr_clk_src_twocell_get(struct of_phandle_args *clkspec,
 		clk = priv->clks[priv->num_core_clks + idx];
 		break;
 
+	case CPG_CD_MOD:
+		if (!priv->cd_base) {
+			dev_err(dev, "control domain is not available\n");
+			return ERR_PTR(-ENXIO);
+		}
+		type = "cd-module";
+		if ((clkidx % 100) >= 32 ||
+		    MOD_CLK_PACK(clkidx) >= priv->num_cd_mod_clks) {
+			dev_err(dev, "Invalid %s clock index %u\n", type,
+				clkidx);
+			return ERR_PTR(-EINVAL);
+		}
+		clk = priv->clks[priv->num_core_clks +
+				 priv->num_mod_clks +
+				 MOD_CLK_PACK(clkidx)];
+		break;
+
 	default:
 		dev_err(dev, "Invalid CPG clock type %u\n", clkspec->args[0]);
 		return ERR_PTR(-EINVAL);
@@ -478,6 +578,84 @@ static void __init cpg_mssr_register_mod_clk(const struct mssr_mod_clk *mod,
 	kfree(clock);
 }
 
+static void __init cpg_mssr_register_cd_mod_clk(const struct mssr_mod_clk *mod,
+						struct cpg_mssr_priv *priv)
+{
+	unsigned int clk_index;
+	struct clk *parent;
+	const char *parent_name;
+	struct clk_init_data mclk_init;
+	struct mstp_clock *mclk;
+	struct clk *clk;
+
+	if (!priv->cd_base)
+		return;
+
+	if (!mod->name) {
+		dev_err(priv->dev, "no cd-mod clock name\n");
+		return;
+	}
+
+	if (mod->id >= priv->num_cd_mod_clks) {
+		dev_err(priv->dev, "invalid id %d for cd-mod clock %s",
+				mod->id, mod->name);
+		return;
+	}
+	clk_index = priv->num_core_clks + priv->num_mod_clks + mod->id;
+	if (PTR_ERR(priv->clks[clk_index]) != -ENOENT) {
+		dev_err(priv->dev, "duplicate id %d for cd-mod clock %s\n",
+				mod->id, mod->name);
+		return;
+	}
+
+	if (mod->parent >= priv->num_core_clks + priv->num_mod_clks) {
+		dev_err(priv->dev, "invalid parent id %d for cd-mod clock %s\n",
+				mod->parent, mod->name);
+		return;
+	}
+	parent = priv->clks[mod->parent];
+	if (IS_ERR(parent)) {
+		dev_err(priv->dev, "no parent clock for cd-mode clock %s\n",
+				mod->name);
+		return;
+	}
+	parent_name = __clk_get_name(parent);
+
+	memset(&mclk_init, 0, sizeof(mclk_init));
+	mclk_init.name = mod->name;
+	mclk_init.ops = &cpg_cd_mstp_clock_ops;
+	mclk_init.flags = CLK_SET_RATE_PARENT;
+	mclk_init.parent_names = &parent_name;
+	mclk_init.num_parents = 1;
+
+	mclk = kzalloc(sizeof(*mclk), GFP_KERNEL);
+	if (!mclk) {
+		dev_err(priv->dev, "failed to allocate cd-mod clock %s\n",
+				mod->name);
+		return;
+	}
+	mclk->index = mod->id;
+	mclk->priv = priv;
+	mclk->hw.init = &mclk_init;
+
+	clk = clk_register(NULL, &mclk->hw);
+	if (IS_ERR(clk)) {
+		dev_err(priv->dev, "failed to register cd-mod clock %s\n",
+				mod->name);
+		goto err_register;
+	}
+
+	priv->clks[clk_index] = clk;
+	dev_dbg(priv->dev, "registered cd-mod clk %s, id %d, rate %ld\n",
+			mod->name,
+			(mod->id / 32 * 100) + (mod->id % 32),
+			clk_get_rate(clk));
+	return;
+
+err_register:
+	kfree(mclk);
+}
+
 struct cpg_mssr_clk_domain {
 	struct generic_pm_domain genpd;
 	unsigned int num_core_pm_clks;
@@ -502,6 +680,7 @@ static bool cpg_mssr_is_pm_clk(const struct of_phandle_args *clkspec,
 		return false;
 
 	case CPG_MOD:
+	case CPG_CD_MOD:
 		return true;
 
 	default:
@@ -966,7 +1145,8 @@ static int __init cpg_mssr_common_init(struct device *dev,
 			return error;
 	}
 
-	nclks = info->num_total_core_clks + info->num_hw_mod_clks;
+	nclks = info->num_total_core_clks + info->num_hw_mod_clks +
+			(32 * info->num_cd_mod_control_regs);
 	priv = kzalloc(struct_size(priv, clks, nclks), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -981,6 +1161,12 @@ static int __init cpg_mssr_common_init(struct device *dev,
 		goto out_err;
 	}
 
+	if (info->num_cd_mod_control_regs) {
+		priv->cd_base = of_iomap(np, 1);
+		/* since now, use non-null cd_base as a check that control
+		 * domain mod clocks exist */
+	}
+
 	cpg_mssr_priv = priv;
 	priv->num_core_clks = info->num_total_core_clks;
 	priv->num_mod_clks = info->num_hw_mod_clks;
@@ -1003,6 +1189,10 @@ static int __init cpg_mssr_common_init(struct device *dev,
 		error = -EINVAL;
 		goto out_err;
 	}
+	if (priv->cd_base) {
+		priv->num_cd_mod_clks = 32 * info->num_cd_mod_control_regs;
+		priv->cd_mod_control_regs = info->cd_mod_control_regs;
+	}
 
 	for (i = 0; i < nclks; i++)
 		priv->clks[i] = ERR_PTR(-ENOENT);
@@ -1016,6 +1206,8 @@ static int __init cpg_mssr_common_init(struct device *dev,
 out_err:
 	if (priv->base)
 		iounmap(priv->base);
+	if (priv->cd_base)
+		iounmap(priv->cd_base);
 	kfree(priv);
 
 	return error;
@@ -1068,6 +1260,9 @@ static int __init cpg_mssr_probe(struct platform_device *pdev)
 	for (i = 0; i < info->num_mod_clks; i++)
 		cpg_mssr_register_mod_clk(&info->mod_clks[i], info, priv);
 
+	for (i = 0; i < info->num_cd_mod_clks; i++)
+		cpg_mssr_register_cd_mod_clk(&info->cd_mod_clks[i], priv);
+
 	error = devm_add_action_or_reset(dev,
 					 cpg_mssr_del_clk_provider,
 					 np);
@@ -1145,5 +1340,12 @@ void __init mssr_mod_reparent(struct mssr_mod_clk *mod_clks,
 		}
 }
 
+void __iomem *cpg_mssr_cd_base(struct device *dev)
+{
+	struct cpg_mssr_priv *priv = dev_get_drvdata(dev);
+
+	return priv->cd_base;
+}
+
 MODULE_DESCRIPTION("Renesas CPG/MSSR Driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/renesas/renesas-cpg-mssr.h b/drivers/clk/renesas/renesas-cpg-mssr.h
index 1e7ceefd0a5c..cebe48aeb91d 100644
--- a/drivers/clk/renesas/renesas-cpg-mssr.h
+++ b/drivers/clk/renesas/renesas-cpg-mssr.h
@@ -75,6 +75,9 @@ struct mssr_mod_clk {
 #define DEF_MOD(_name, _mod, _parent...)	\
 	{ .name = _name, .id = MOD_CLK_ID(_mod), .parent = _parent }
 
+#define DEF_CD_MOD(_name, _id, _parent)		\
+	{ .name = _name, .id = MOD_CLK_PACK(_id), .parent = _parent }
+
 /* Convert from sparse base-10 to packed index space */
 #define MOD_CLK_PACK_10(x)	((x / 10) * 32 + (x % 10))
 
@@ -155,6 +158,12 @@ struct cpg_mssr_info {
 					const struct cpg_mssr_info *info,
 					struct clk **clks, void __iomem *base,
 					struct raw_notifier_head *notifiers);
+
+	/* Support for control domain module clocks */
+	const u16 *cd_mod_control_regs;
+	unsigned int num_cd_mod_control_regs;
+	const struct mssr_mod_clk *cd_mod_clks;
+	unsigned int num_cd_mod_clks;
 };
 
 extern const struct cpg_mssr_info r7s9210_cpg_mssr_info;
@@ -204,4 +213,8 @@ extern void mssr_mod_reparent(struct mssr_mod_clk *mod_clks,
 			      unsigned int num_mod_clks,
 			      const struct mssr_mod_reparent *clks,
 			      unsigned int n);
+
+/* HACK: access to control domain register base */
+void __iomem *cpg_mssr_cd_base(struct device *dev);
+
 #endif
diff --git a/drivers/soc/renesas/rcar-rst.c b/drivers/soc/renesas/rcar-rst.c
index 4c3599889643..5ccadd7fed6a 100644
--- a/drivers/soc/renesas/rcar-rst.c
+++ b/drivers/soc/renesas/rcar-rst.c
@@ -28,6 +28,7 @@ static int rcar_rst_gen4_enable_wdt_reset(void __iomem *base)
 
 struct rst_config {
 	unsigned int modemr;		/* Mode Monitoring Register Offset */
+	unsigned int modemr2;		/* Second Mode Monitor Register Offset */
 	int (*configure)(void __iomem *base);	/* Platform specific config */
 };
 
@@ -50,6 +51,7 @@ static const struct rst_config rcar_rst_r8a779a0 __initconst = {
 
 static const struct rst_config rcar_rst_gen4 __initconst = {
 	.modemr = 0x00,		/* MODEMR0 and it has CPG related bits */
+	.modemr2 = 0x04,
 	.configure = rcar_rst_gen4_enable_wdt_reset,
 };
 
@@ -94,6 +96,7 @@ static const struct of_device_id rcar_rst_matches[] __initconst = {
 
 static void __iomem *rcar_rst_base __initdata;
 static u32 saved_mode __initdata;
+static u32 saved_mode_2 __initdata;
 
 static int __init rcar_rst_init(void)
 {
@@ -117,6 +120,8 @@ static int __init rcar_rst_init(void)
 	rcar_rst_base = base;
 	cfg = match->data;
 	saved_mode = ioread32(base + cfg->modemr);
+	if (cfg->modemr2)	/* for second reg, zero means "undefined" */
+		saved_mode_2 = ioread32(base + cfg->modemr2);
 	if (cfg->configure) {
 		error = cfg->configure(base);
 		if (error) {
@@ -146,3 +151,17 @@ int __init rcar_rst_read_mode_pins(u32 *mode)
 	*mode = saved_mode;
 	return 0;
 }
+
+int __init rcar_rst_read_mode_pins_64(u64 *mode)
+{
+	int error;
+
+	if (!rcar_rst_base) {
+		error = rcar_rst_init();
+		if (error)
+			return error;
+	}
+
+	*mode = saved_mode | (((u64)saved_mode_2) << 32);
+	return 0;
+}
diff --git a/include/dt-bindings/clock/r8a779f0-cpg-mssr.h b/include/dt-bindings/clock/r8a779f0-cpg-mssr.h
index d258e7ff4eee..f2cea27ae647 100644
--- a/include/dt-bindings/clock/r8a779f0-cpg-mssr.h
+++ b/include/dt-bindings/clock/r8a779f0-cpg-mssr.h
@@ -62,5 +62,9 @@
 #define R8A779F0_CLK_CBFUSA		51
 #define R8A779F0_CLK_R			52
 #define R8A779F0_CLK_OSC		53
+#define R8A779F0_CLK_CD_CANFD		54
+#define R8A779F0_CLK_CD_MSPI		55
+
+#define R8A779F0_LAST_CORE_CLK		55
 
 #endif /* __DT_BINDINGS_CLOCK_R8A779F0_CPG_MSSR_H__ */
diff --git a/include/dt-bindings/clock/renesas-cpg-mssr.h b/include/dt-bindings/clock/renesas-cpg-mssr.h
index 8169ad063f0a..78ae2c55130d 100644
--- a/include/dt-bindings/clock/renesas-cpg-mssr.h
+++ b/include/dt-bindings/clock/renesas-cpg-mssr.h
@@ -7,5 +7,6 @@
 
 #define CPG_CORE			0	/* Core Clock */
 #define CPG_MOD				1	/* Module Clock */
+#define CPG_CD_MOD			2	/* Control Domain Module Clock */
 
 #endif /* __DT_BINDINGS_CLOCK_RENESAS_CPG_MSSR_H__ */
diff --git a/include/linux/soc/renesas/rcar-rst.h b/include/linux/soc/renesas/rcar-rst.h
index 7899a5b8c247..e73330b9b1c3 100644
--- a/include/linux/soc/renesas/rcar-rst.h
+++ b/include/linux/soc/renesas/rcar-rst.h
@@ -4,6 +4,7 @@
 
 #ifdef CONFIG_RST_RCAR
 int rcar_rst_read_mode_pins(u32 *mode);
+int rcar_rst_read_mode_pins_64(u64 *mode);
 #else
 static inline int rcar_rst_read_mode_pins(u32 *mode) { return -ENODEV; }
 #endif
-- 
2.30.2

